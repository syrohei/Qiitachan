{"items":[{"rendered_body":"\n<h2>\n<span id=\"概要\" class=\"fragment\"></span><a href=\"#%E6%A6%82%E8%A6%81\"><i class=\"fa fa-link\"></i></a>概要</h2>\n\n<p>EthereumのGoクライアントである「Geth」と、SmartContractの記述言語である「Solidity」を用いることにより、SmartContractを自ら作成することが出来ます。<br>\nしかし、コーディングしコンパイルし動作を確認する、という作業を試行錯誤しながらコマンドライン上で繰り返すのは非効率であり、そんな時に開発環境として便利なツールがいくつか存在しております。<br>\nその中の1つである、<a href=\"https://github.com/chriseth/browser-solidity\">Browser-solidity</a>というIDEの使い方を見ていきたいと思います。</p>\n\n<p>このIDEはSolidityの開発者がMeteorで作成しており、IDEのコード自体を読むこともSmartContractやMeteorを学ぶにも良い教材となりそうです。</p>\n\n<h2>\n<span id=\"主な使い方\" class=\"fragment\"></span><a href=\"#%E4%B8%BB%E3%81%AA%E4%BD%BF%E3%81%84%E6%96%B9\"><i class=\"fa fa-link\"></i></a>主な使い方</h2>\n\n<p>このIDEを通してEthereumと接続できるため、コーディング、コンパイルされたものをワンクリックでBlockchain上に登録することが可能です。<br>\nなので、SmartContractをこのIDEで試行錯誤しながら作成し、完成したら実際にアプリケーションに組み込んで、Dappsを作成する、といった流れが良いと思います。</p>\n\n<h2>\n<span id=\"ideの準備\" class=\"fragment\"></span><a href=\"#ide%E3%81%AE%E6%BA%96%E5%82%99\"><i class=\"fa fa-link\"></i></a>IDEの準備</h2>\n\n<p>主に下記の方法があります。<br>\n1. 公開されているクラウドIDEを利用(<a href=\"https://ethereum.github.io/browser-solidity/\" class=\"autolink\">https://ethereum.github.io/browser-solidity/</a>)<br>\n2. <a href=\"https://github.com/ethereum/browser-solidity\">GitHub</a>からクローンしてきてローカルで立ち上げ</p>\n\n<p>今回は1の方法で進めます。</p>\n\n<h2>\n<span id=\"gethとの接続\" class=\"fragment\"></span><a href=\"#geth%E3%81%A8%E3%81%AE%E6%8E%A5%E7%B6%9A\"><i class=\"fa fa-link\"></i></a>gethとの接続</h2>\n\n<p>gethを用いてEthereumを立ち上げます。<br><br>\n今回はテスト用なので、下記コマンドでprivate_netを立ち上げます。</p>\n\n<p><code>geth --networkid \"11\"  --datadir \"path_to_directory\" --genesis \"path_to_genesisjson\" --unlock \"your_account_password\" --rpc --rpcaddr \"localhost\" --rpcport \"8545\" --rpccorsdomain \"*\" console</code></p>\n\n<ul>\n<li>\n<code>-networkid</code> ：networkIDを指定します。1,2,3以外の数字を使いましょう。</li>\n<li>\n<code>-genesis</code>　：genesis blockを指定します。</li>\n<li>\n<code>-datadir</code>　：databaseのあるディレクトリを指定します。</li>\n<li>\n<code>console</code>　　：consoleを開くために必要です。</li>\n</ul>\n\n<p>その他のオプションについてはこちらを参考に。<br>\n<a href=\"https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options\">Geth command line options</a></p>\n\n<p>そして、IDEにアクセスし、下記の画像のように右枠の左から3つ目(立方体マーク)を選択し、「Web3 Provider」にチェックを入れます。<br>\nそうすると、確認ダイアログが出てくるのでOKを押します。<br>\n(Endpointは、上記立ち上げ時に指定したrpcaddressとrpcportを入力してください)</p>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/372f5b07-bdf2-0018-7c7b-cdc183e7a289.png\" target=\"_blank\"><img width=\"1427\" alt=\"Screen Shot 2016-06-09 at 12.09.27.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/372f5b07-bdf2-0018-7c7b-cdc183e7a289.png\"></a></p>\n\n<p>ここでエラーが表示されなかったら無事Blockchainとの接続が完了しています。</p>\n\n<h2>\n<span id=\"solidityを書いてみる\" class=\"fragment\"></span><a href=\"#solidity%E3%82%92%E6%9B%B8%E3%81%84%E3%81%A6%E3%81%BF%E3%82%8B\"><i class=\"fa fa-link\"></i></a>Solidityを書いてみる</h2>\n\n<p>Solidity言語の記述方法は奥が深いので、今回はコピペとさせてください。<br>\n下記記事にあるコードを貼り付けます。</p>\n\n<p><strong>記事</strong><br>\n<a href=\"http://qiita.com/toshikase/items/467f8998506a2f0cf258\" id=\"reference-d9c319e9191d413d0dc9\">Solidityによるコントラクトの作成(2) - オプション取引</a></p>\n\n<p><strong>コード</strong></p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\ncontract CallOption{\n    address public buyer;\n    address public seller;\n    uint public btc_amount;\n    uint public btc_price;\n    uint public premium;\n    uint public exercise_date;\n    mapping (address =&gt; uint) public balanceOfJPY;\n    mapping (address =&gt; uint) public balanceOfBTC;\n    function CallOption(\n      address _seller,\n      uint _seller_jpy,\n      uint _seller_btc,\n      uint _btc_price,\n      uint _btc_amount,\n      uint _premium,\n      uint _exercise_date\n      ){\n      seller = _seller;\n      balanceOfJPY[seller] = _seller_jpy;\n      balanceOfBTC[seller] = _seller_btc;\n      btc_price = _btc_price;\n      btc_amount = _btc_amount;\n      premium = _premium;\n      exercise_date = _exercise_date;\n    }\n    function Respond (address _buyer, uint _buyer_jpy) {\n      buyer = _buyer;\n      balanceOfJPY[buyer] = _buyer_jpy;\n      if (balanceOfJPY[buyer] &lt; premium + btc_amount * btc_price) throw;\n      balanceOfJPY[buyer] -= premium;\n      balanceOfJPY[seller] += premium;\n    }\n    function Expire (uint _current_btc_price, uint _current_time){\n      if (_current_time &lt; exercise_date) throw;\n      if (_current_btc_price &lt; btc_price) throw;\n      balanceOfJPY[buyer] -= btc_price * btc_amount;\n      balanceOfJPY[seller] += btc_price * btc_amount;\n      balanceOfBTC[buyer] += btc_amount;\n      balanceOfBTC[seller] -= btc_amount;\n    }\n    function () {\n      throw;\n    }\n}\n</pre></div></div>\n\n<h2>\n<span id=\"smartcontractの実行\" class=\"fragment\"></span><a href=\"#smartcontract%E3%81%AE%E5%AE%9F%E8%A1%8C\"><i class=\"fa fa-link\"></i></a>SmartContractの実行</h2>\n\n<p>コードを貼り付けたら、下記画像1のように、コンストラクタの情報を入れて「Create」ボタンを押します。<br>\nこれがContractをBlockchainに登録する作業になり、成功するとContractのアドレスや各パラメータの情報などが表示されます。</p>\n\n<p><strong>画像1</strong><br>\n<a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/c9581422-a0a0-e1d6-2e6f-3330a6037b4d.png\" target=\"_blank\"><img width=\"430\" alt=\"Screen Shot 2016-06-09 at 12.23.02.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/c9581422-a0a0-e1d6-2e6f-3330a6037b4d.png\"></a></p>\n\n<p>その後、下記画像2のように「Expire」や「Respond」とメソッド名が表示されているはずなので、そこに数値や文字列を入れて当該ボタンを押すことで登録されたContractにメソッドを送ることが可能になります。<br>\nまたコンパイル後のByteconde等、その他の情報も下部に表示されています。</p>\n\n<p><strong>画像2</strong><br>\n<a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/424d33a6-adeb-225b-fc22-9be5361ac939.png\" target=\"_blank\"><img width=\"411\" alt=\"Screen Shot 2016-06-09 at 12.23.43.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/424d33a6-adeb-225b-fc22-9be5361ac939.png\"></a></p>\n\n<h2>\n<span id=\"まとめ\" class=\"fragment\"></span><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"><i class=\"fa fa-link\"></i></a>まとめ</h2>\n\n<p>まだまだEthereum自体が仕様の変更など多く、Browser-solidityもそれに伴って変わっていく可能性はありますが、現時点ではSmartContractを用いた開発には非常に有用なツールだと思います。<br>\n是非触って遊んでみてください。</p>\n\n<h2>\n<span id=\"参考リンク\" class=\"fragment\"></span><a href=\"#%E5%8F%82%E8%80%83%E3%83%AA%E3%83%B3%E3%82%AF\"><i class=\"fa fa-link\"></i></a>参考リンク</h2>\n\n<ul>\n<li><a href=\"https://github.com/ethereum/browser-solidity\">ethereum/browser-solidity</a></li>\n<li><a href=\"http://book.ethereum-jp.net/first_use/realtimecompiler.html\">Ethereum入門 [Contract開発環境（IDE）の活用]</a></li>\n</ul>\n","body":"## 概要\nEthereumのGoクライアントである「Geth」と、SmartContractの記述言語である「Solidity」を用いることにより、SmartContractを自ら作成することが出来ます。\nしかし、コーディングしコンパイルし動作を確認する、という作業を試行錯誤しながらコマンドライン上で繰り返すのは非効率であり、そんな時に開発環境として便利なツールがいくつか存在しております。\nその中の1つである、[Browser-solidity](https://github.com/chriseth/browser-solidity)というIDEの使い方を見ていきたいと思います。\n\nこのIDEはSolidityの開発者がMeteorで作成しており、IDEのコード自体を読むこともSmartContractやMeteorを学ぶにも良い教材となりそうです。\n\n## 主な使い方\nこのIDEを通してEthereumと接続できるため、コーディング、コンパイルされたものをワンクリックでBlockchain上に登録することが可能です。\nなので、SmartContractをこのIDEで試行錯誤しながら作成し、完成したら実際にアプリケーションに組み込んで、Dappsを作成する、といった流れが良いと思います。\n\n## IDEの準備\n主に下記の方法があります。\n1. 公開されているクラウドIDEを利用(https://ethereum.github.io/browser-solidity/)\n2. [GitHub](https://github.com/ethereum/browser-solidity)からクローンしてきてローカルで立ち上げ\n\n今回は1の方法で進めます。\n\n## gethとの接続\ngethを用いてEthereumを立ち上げます。  \n今回はテスト用なので、下記コマンドでprivate_netを立ち上げます。\n\n`geth --networkid \"11\"  --datadir \"path_to_directory\" --genesis \"path_to_genesisjson\" --unlock \"your_account_password\" --rpc --rpcaddr \"localhost\" --rpcport \"8545\" --rpccorsdomain \"*\" console`\n\n- `-networkid` ：networkIDを指定します。1,2,3以外の数字を使いましょう。\n- `-genesis`　：genesis blockを指定します。\n- `-datadir`　：databaseのあるディレクトリを指定します。\n- `console`　　：consoleを開くために必要です。\n\nその他のオプションについてはこちらを参考に。\n[Geth command line options](https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options)\n\n\nそして、IDEにアクセスし、下記の画像のように右枠の左から3つ目(立方体マーク)を選択し、「Web3 Provider」にチェックを入れます。\nそうすると、確認ダイアログが出てくるのでOKを押します。\n(Endpointは、上記立ち上げ時に指定したrpcaddressとrpcportを入力してください)\n\n<img width=\"1427\" alt=\"Screen Shot 2016-06-09 at 12.09.27.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/372f5b07-bdf2-0018-7c7b-cdc183e7a289.png\">\n\nここでエラーが表示されなかったら無事Blockchainとの接続が完了しています。\n\n\n## Solidityを書いてみる\nSolidity言語の記述方法は奥が深いので、今回はコピペとさせてください。\n下記記事にあるコードを貼り付けます。\n\n**記事**\n[Solidityによるコントラクトの作成(2) - オプション取引](http://qiita.com/toshikase/items/467f8998506a2f0cf258)\n\n**コード**\n\n```\ncontract CallOption{\n    address public buyer;\n    address public seller;\n    uint public btc_amount;\n    uint public btc_price;\n    uint public premium;\n    uint public exercise_date;\n    mapping (address => uint) public balanceOfJPY;\n    mapping (address => uint) public balanceOfBTC;\n    function CallOption(\n      address _seller,\n      uint _seller_jpy,\n      uint _seller_btc,\n      uint _btc_price,\n      uint _btc_amount,\n      uint _premium,\n      uint _exercise_date\n      ){\n      seller = _seller;\n      balanceOfJPY[seller] = _seller_jpy;\n      balanceOfBTC[seller] = _seller_btc;\n      btc_price = _btc_price;\n      btc_amount = _btc_amount;\n      premium = _premium;\n      exercise_date = _exercise_date;\n    }\n    function Respond (address _buyer, uint _buyer_jpy) {\n      buyer = _buyer;\n      balanceOfJPY[buyer] = _buyer_jpy;\n      if (balanceOfJPY[buyer] < premium + btc_amount * btc_price) throw;\n      balanceOfJPY[buyer] -= premium;\n      balanceOfJPY[seller] += premium;\n    }\n    function Expire (uint _current_btc_price, uint _current_time){\n      if (_current_time < exercise_date) throw;\n      if (_current_btc_price < btc_price) throw;\n      balanceOfJPY[buyer] -= btc_price * btc_amount;\n      balanceOfJPY[seller] += btc_price * btc_amount;\n      balanceOfBTC[buyer] += btc_amount;\n      balanceOfBTC[seller] -= btc_amount;\n    }\n    function () {\n      throw;\n    }\n}\n```\n\n## SmartContractの実行\nコードを貼り付けたら、下記画像1のように、コンストラクタの情報を入れて「Create」ボタンを押します。\nこれがContractをBlockchainに登録する作業になり、成功するとContractのアドレスや各パラメータの情報などが表示されます。\n\n**画像1**\n<img width=\"430\" alt=\"Screen Shot 2016-06-09 at 12.23.02.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/c9581422-a0a0-e1d6-2e6f-3330a6037b4d.png\">\n\nその後、下記画像2のように「Expire」や「Respond」とメソッド名が表示されているはずなので、そこに数値や文字列を入れて当該ボタンを押すことで登録されたContractにメソッドを送ることが可能になります。\nまたコンパイル後のByteconde等、その他の情報も下部に表示されています。\n\n**画像2**\n<img width=\"411\" alt=\"Screen Shot 2016-06-09 at 12.23.43.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/424d33a6-adeb-225b-fc22-9be5361ac939.png\">\n\n\n## まとめ\nまだまだEthereum自体が仕様の変更など多く、Browser-solidityもそれに伴って変わっていく可能性はありますが、現時点ではSmartContractを用いた開発には非常に有用なツールだと思います。\n是非触って遊んでみてください。\n\n## 参考リンク\n- [ethereum/browser-solidity](https://github.com/ethereum/browser-solidity)\n- [Ethereum入門 [Contract開発環境（IDE）の活用]](http://book.ethereum-jp.net/first_use/realtimecompiler.html)\n","coediting":false,"created_at":"2016-06-09T12:30:34+09:00","id":"c00dd5d2f238309f4bba","private":false,"tags":[{"name":"Meteor","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]},{"name":"SmartContract","versions":[]}],"title":"Smartcontractの開発を効率化するBrowser-solidityの使い方","updated_at":"2016-06-09T12:31:23+09:00","url":"http://qiita.com/Y-Mukoyama/items/c00dd5d2f238309f4bba","user":{"description":"","facebook_id":"yusuke.mukoyama.3","followees_count":2,"followers_count":2,"github_login_name":"YusukeMukoyama","id":"Y-Mukoyama","items_count":19,"linkedin_id":"","location":"Tokyo","name":"Yusuke Mukoyama","organization":"","permanent_id":87650,"profile_image_url":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/87650/721f6204557100b8cccc56e4e67a36f85f3eacf5/medium.png?1450101576","twitter_screen_name":"mukoyam","website_url":""}},{"rendered_body":"<p>最終回です。</p>\n\n<p>これまでの記事<br>\n1. <a href=\"http://qiita.com/Y-Mukoyama/items/5d751dc01ea4a45dc850\" id=\"reference-138ec5513b39a8186413\">Boilerplateを使ったDapps(分散型アプリケーション)の作成(1)</a><br>\n2. <a href=\"http://qiita.com/Y-Mukoyama/items/0b0f094683805099213d\" id=\"reference-24fc87a92a85fbfeea96\">Boilerplateを使ったDapps(分散型アプリケーション)の作成(2)</a><br>\n3. <a href=\"http://qiita.com/Y-Mukoyama/items/36586d4b2a7e550bf2e1\" id=\"reference-ee833930e847e0d22601\">Boilerplateを使ったDapps(分散型アプリケーション)の作成(3)</a></p>\n\n<p>最後に<br>\n- Mongoに登録されたコントラクト一覧を表示する機能<br>\n- その契約の詳細を表示する機能<br>\nを実装したいと思います。</p>\n\n<h2>\n<span id=\"2契約一覧画面\" class=\"fragment\"></span><a href=\"#2%E5%A5%91%E7%B4%84%E4%B8%80%E8%A6%A7%E7%94%BB%E9%9D%A2\"><i class=\"fa fa-link\"></i></a>2.契約一覧画面</h2>\n\n<p>MongoDBに登録された契約一覧を呼び出して、一覧表を作成します。</p>\n\n<h3>\n<span id=\"1-view\" class=\"fragment\"></span><a href=\"#1-view\"><i class=\"fa fa-link\"></i></a>(1) View</h3>\n\n<p>最終的なコードは下記のようになりました。</p>\n\n<div class=\"code-frame\" data-lang=\"html\">\n<div class=\"code-lang\"><span class=\"bold\">index.html</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nt\">&lt;template</span> <span class=\"na\">name=</span><span class=\"s\">\"components_index\"</span><span class=\"nt\">&gt;</span>\n    <span class=\"c\">&lt;!-- 商品一覧パネル --&gt;</span>\n    <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"panel panel-default\"</span><span class=\"nt\">&gt;</span>\n        <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"panel-heading\"</span><span class=\"nt\">&gt;</span>\n            <span class=\"nt\">&lt;h4&gt;</span>契約一覧<span class=\"nt\">&lt;/h4&gt;</span>\n        <span class=\"nt\">&lt;/div&gt;</span>\n        <span class=\"nt\">&lt;table</span> <span class=\"na\">class=</span><span class=\"s\">\"table\"</span><span class=\"nt\">&gt;</span>\n            <span class=\"nt\">&lt;thead&gt;</span>\n                <span class=\"nt\">&lt;tr&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>商品ID<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>取引先<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>想定元本<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>固定金利<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>変動金利<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>自社ポジション<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>期日<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>ステータス<span class=\"nt\">&lt;/th&gt;</span>\n                    <span class=\"nt\">&lt;th&gt;</span>契約詳細<span class=\"nt\">&lt;/th&gt;</span>\n                <span class=\"nt\">&lt;/tr&gt;</span>\n            <span class=\"nt\">&lt;/thead&gt;</span>\n            <span class=\"nt\">&lt;tbody&gt;</span>\n        {{&gt; contract}}\n    <span class=\"nt\">&lt;/tbody&gt;</span>\n<span class=\"nt\">&lt;/table&gt;</span>\n<span class=\"nt\">&lt;/div&gt;</span>\n<span class=\"nt\">&lt;/template&gt;</span>\n\n<span class=\"c\">&lt;!-- 上記の{{contract}}に格納 --&gt;</span>\n<span class=\"nt\">&lt;template</span> <span class=\"na\">name=</span><span class=\"s\">\"contract\"</span><span class=\"nt\">&gt;</span>\n    <span class=\"c\">&lt;!-- index.js にcontractsのヘルパーを記載することで下記の{{}}内に変数が格納される --&gt;</span>\n    {{#each contracts}}\n      <span class=\"nt\">&lt;tr&gt;</span>\n          <span class=\"nt\">&lt;td</span> <span class=\"na\">id=</span><span class=\"s\">\"_id\"</span><span class=\"nt\">&gt;</span>{{_id}}<span class=\"nt\">&lt;/td&gt;</span>\n          <span class=\"nt\">&lt;td</span> <span class=\"na\">id=</span><span class=\"s\">\"client\"</span><span class=\"nt\">&gt;</span>{{client}}<span class=\"nt\">&lt;/td&gt;</span>\n          <span class=\"nt\">&lt;td</span> <span class=\"na\">id=</span><span class=\"s\">\"price\"</span><span class=\"nt\">&gt;</span>{{price}}<span class=\"nt\">&lt;/td&gt;</span>\n          <span class=\"nt\">&lt;td</span> <span class=\"na\">id=</span><span class=\"s\">\"fixed_rate\"</span><span class=\"nt\">&gt;</span>{{fixedRate}}<span class=\"nt\">&lt;/td&gt;</span>\n          <span class=\"nt\">&lt;td</span> <span class=\"na\">id=</span><span class=\"s\">\"floated_rate\"</span><span class=\"nt\">&gt;</span>TIBOR + {{spread}}<span class=\"nt\">&lt;/td&gt;</span>\n          <span class=\"nt\">&lt;td</span> <span class=\"na\">id=</span><span class=\"s\">\"position\"</span><span class=\"nt\">&gt;</span>{{position}}<span class=\"nt\">&lt;/td&gt;</span>\n          <span class=\"nt\">&lt;td</span> <span class=\"na\">id=</span><span class=\"s\">\"expired_date\"</span><span class=\"nt\">&gt;</span>{{expiredDate}}<span class=\"nt\">&lt;/td&gt;</span>\n      {{#if done}}\n          <span class=\"nt\">&lt;td&gt;&lt;button</span> <span class=\"na\">type=</span><span class=\"s\">\"button\"</span> <span class=\"na\">class=</span><span class=\"s\">\"btn btn-success\"</span><span class=\"nt\">&gt;</span>実行済<span class=\"nt\">&lt;/button&gt;&lt;/td&gt;</span>\n      {{else}}\n          <span class=\"nt\">&lt;td&gt;&lt;button</span> <span class=\"na\">type=</span><span class=\"s\">\"button\"</span> <span class=\"na\">class=</span><span class=\"s\">\"btn btn-default\"</span><span class=\"nt\">&gt;</span>未実行<span class=\"nt\">&lt;/button&gt;&lt;/td&gt;</span>\n      {{/if}}\n      <span class=\"nt\">&lt;td&gt;&lt;button</span> <span class=\"na\">type=</span><span class=\"s\">\"button\"</span> <span class=\"na\">class=</span><span class=\"s\">\"btn btn-warning\"</span><span class=\"nt\">&gt;&lt;a</span> <span class=\"na\">href =</span><span class=\"s\">\"/contract/{{_id}}\"</span> <span class=\"na\">style=</span><span class=\"s\">\"color:#fff;\"</span><span class=\"nt\">&gt;</span>契約詳細<span class=\"nt\">&lt;/a&gt;&lt;/button&gt;&lt;/td&gt;</span>\n      <span class=\"nt\">&lt;/tr&gt;</span>\n    {{/each}}\n<span class=\"nt\">&lt;/template&gt;</span>\n</pre></div>\n</div>\n\n<p>Meteorは<a href=\"http://guide.meteor.com/blaze.html\">Blaze</a>というレンダリングエンジンを仕様しています。<br>\n前回同様、Templateで他のレイアウト側のHTMLファイルから呼び出しを行っています。<br>\ncontractテンプレート(上記コードの後半部分)の <code>{{ }}</code> 部分は、(2)で後述するヘルパーから変数を取得しています。<br>\nまた、契約詳細画面へのリンクを、idをURLとして動的に作成するため、<br>\n<code>&lt;a href =\"/contract/{{_id}}\" style=\"color:#fff;\"&gt;契約詳細&lt;/a&gt;</code><br>\nこのようにリンクを貼っています。</p>\n\n<h3>\n<span id=\"2jsファイル\" class=\"fragment\"></span><a href=\"#2js%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB\"><i class=\"fa fa-link\"></i></a>(2)JSファイル</h3>\n\n<p>こちらは非常にシンプルです。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">index.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nx\">Template</span><span class=\"p\">.</span><span class=\"nx\">contract</span><span class=\"p\">.</span><span class=\"nx\">helpers</span><span class=\"p\">({</span>\n <span class=\"nx\">contracts</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n   <span class=\"nx\">Meteor</span><span class=\"p\">.</span><span class=\"nx\">subscribe</span><span class=\"p\">(</span><span class=\"s1\">'contracts'</span><span class=\"p\">);</span>  <span class=\"c1\">//serverのcontractsをsubscribeする</span>\n   <span class=\"k\">return</span> <span class=\"nx\">Contracts</span><span class=\"p\">.</span><span class=\"nx\">find</span><span class=\"p\">();</span>  <span class=\"c1\">//main.jsにcontractsの配列を返す</span>\n <span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<p>contractテンプレートに渡す <code>contracts</code> という配列をヘルパーとして取得しています。<br>\n<code>Meteor.subscribe</code> は、(3)で記載する <code>publish</code> とセットにすることで、DB内のコレクションにアクセスすることが可能になります。</p>\n\n<h3>\n<span id=\"3サーバー側\" class=\"fragment\"></span><a href=\"#3%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E5%81%B4\"><i class=\"fa fa-link\"></i></a>(3)サーバー側</h3>\n\n<p>前回のコードに下記を追記します。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">server/main.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"p\">....</span>\n    <span class=\"nx\">Meteor</span><span class=\"p\">.</span><span class=\"nx\">publish</span><span class=\"p\">(</span><span class=\"s1\">'contracts'</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"c1\">//client側にpublishする</span>\n      <span class=\"k\">return</span> <span class=\"nx\">Contracts</span><span class=\"p\">.</span><span class=\"nx\">find</span><span class=\"p\">({});</span>  <span class=\"c1\">//全ての配列</span>\n    <span class=\"p\">});</span>\n<span class=\"p\">...</span>\n</pre></div>\n</div>\n\n<p>これにより、(2)の <code>subscribe</code> で取得可能になります。<br>\n<code>subscribe</code> と <code>public</code> はセットで使用すると覚えましょう。</p>\n\n<h3>\n<span id=\"4最終形\" class=\"fragment\"></span><a href=\"#4%E6%9C%80%E7%B5%82%E5%BD%A2\"><i class=\"fa fa-link\"></i></a>(4)最終形</h3>\n\n<p>これらのコードにより最終的に下記のような画面が作成されました。</p>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/5fb35be8-ede6-2566-20ae-0fc611d12715.png\" target=\"_blank\"><img width=\"1428\" alt=\"Screen Shot 2016-05-24 at 22.15.01.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/5fb35be8-ede6-2566-20ae-0fc611d12715.png\"></a></p>\n\n<p>DB内に入っているContractコレクションを一覧として取得して表示しています。<br>\nまた、ステータスはパラメータの値に応じて、ボタンが切り替わる用にViewでif分岐をしています。<br>\nそして、契約詳細ボタンは、各契約の詳細ページに飛ぶリンクとなっています。</p>\n\n<h2>\n<span id=\"3契約詳細画面\" class=\"fragment\"></span><a href=\"#3%E5%A5%91%E7%B4%84%E8%A9%B3%E7%B4%B0%E7%94%BB%E9%9D%A2\"><i class=\"fa fa-link\"></i></a>3.契約詳細画面</h2>\n\n<p>動的に生成されたURIから飛ぶ、契約詳細ページを作成します。</p>\n\n<h3>\n<span id=\"1ルーティング\" class=\"fragment\"></span><a href=\"#1%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0\"><i class=\"fa fa-link\"></i></a>(1)ルーティング</h3>\n\n<p>Boilerplateは、Meteorのルーティング用ライブラリのデファクトスタンダードと言える、「Iron router」を使用しています。<br>\n動的にContractsコレクションのIDでview4というテンプレートにリンクを貼るコードは下記のようになります。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">client/templates/routes.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nx\">Router</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">route</span><span class=\"p\">(</span><span class=\"s1\">'view4'</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n    <span class=\"nx\">path</span><span class=\"o\">:</span> <span class=\"s1\">'contract/:_id'</span><span class=\"p\">,</span>    <span class=\"c1\">//URLの生成</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"nx\">Contracts</span><span class=\"p\">.</span><span class=\"nx\">findOne</span><span class=\"p\">({</span><span class=\"nx\">_id</span><span class=\"o\">:</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">params</span><span class=\"p\">.</span><span class=\"nx\">_id</span><span class=\"p\">});}</span>\n  <span class=\"p\">});</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<p>最後の行により、<code>this.params._id</code> でViewもしくはJS側から _idを取得することが可能になります。</p>\n\n<h3>\n<span id=\"2view\" class=\"fragment\"></span><a href=\"#2view\"><i class=\"fa fa-link\"></i></a>(2)View</h3>\n\n<p>下記抜粋です。2と同じように、JSファイルからヘルパーとして渡された変数を表示するようになっています。</p>\n\n<div class=\"code-frame\" data-lang=\"html\">\n<div class=\"code-lang\"><span class=\"bold\">info.html</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nt\">&lt;template</span> <span class=\"na\">name=</span><span class=\"s\">\"contract_detail\"</span><span class=\"nt\">&gt;</span>\n    <span class=\"nt\">&lt;tr&gt;</span>\n        <span class=\"nt\">&lt;th&gt;</span>商品ID<span class=\"nt\">&lt;/th&gt;</span>\n        <span class=\"nt\">&lt;td&gt;</span>{{_id}}<span class=\"nt\">&lt;/td&gt;</span>\n    <span class=\"nt\">&lt;/tr&gt;</span>\n    <span class=\"nt\">&lt;tr&gt;</span>\n        <span class=\"nt\">&lt;th&gt;</span>契約名<span class=\"nt\">&lt;/th&gt;</span>\n        <span class=\"nt\">&lt;td&gt;</span>{{contract_name}}<span class=\"nt\">&lt;/td&gt;</span>\n    <span class=\"nt\">&lt;/tr&gt;</span>\n    <span class=\"nt\">&lt;tr&gt;</span>\n        <span class=\"nt\">&lt;th&gt;</span>相手企業名<span class=\"nt\">&lt;/th&gt;</span>\n        <span class=\"nt\">&lt;td&gt;</span>{{client_name}}<span class=\"nt\">&lt;/td&gt;</span>\n    <span class=\"nt\">&lt;/tr&gt;</span>\n    <span class=\"nt\">&lt;tr&gt;</span>\n        <span class=\"nt\">&lt;th&gt;</span>自社ポジション<span class=\"nt\">&lt;/th&gt;</span>\n        <span class=\"nt\">&lt;td&gt;</span>{{position}}<span class=\"nt\">&lt;/td&gt;</span>\n    <span class=\"nt\">&lt;/tr&gt;</span>\n\n.....略.....\n\n<span class=\"nt\">&lt;/template&gt;</span>\n</pre></div>\n</div>\n\n<h3>\n<span id=\"3jsファイル\" class=\"fragment\"></span><a href=\"#3js%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB\"><i class=\"fa fa-link\"></i></a>(3)JSファイル</h3>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">info.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nx\">Template</span><span class=\"p\">.</span><span class=\"nx\">contract_detail</span><span class=\"p\">.</span><span class=\"nx\">helpers</span><span class=\"p\">({</span>\n   <span class=\"nx\">details</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n     <span class=\"nx\">Meteor</span><span class=\"p\">.</span><span class=\"nx\">subscribe</span><span class=\"p\">(</span><span class=\"s1\">'contracts'</span><span class=\"p\">);</span>  <span class=\"c1\">//serverのcontractsをsubscribeする</span>\n     <span class=\"k\">return</span> <span class=\"nx\">Contracts</span><span class=\"p\">.</span><span class=\"nx\">findOne</span><span class=\"p\">({</span><span class=\"nx\">_id</span><span class=\"o\">:</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">params</span><span class=\"p\">.</span><span class=\"nx\">_id</span><span class=\"p\">});</span>  <span class=\"c1\">//info.jsに動的なidで取得したオブジェクトを渡す</span>\n   <span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<p><code>subscribe</code>は、2と同じです。<br>\nルーティングファイルからidを取得できるため、コレクションからそのidで検索したオブジェクトをView側に渡しています。</p>\n\n<h3>\n<span id=\"4最終形-1\" class=\"fragment\"></span><a href=\"#4%E6%9C%80%E7%B5%82%E5%BD%A2-1\"><i class=\"fa fa-link\"></i></a>(4)最終形</h3>\n\n<p>下記のような画面が作成されました (開発の都合上、空欄が発生してしまっていますが...) </p>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/6c091e10-61b3-de55-34b6-6d8fc9181a4f.png\" target=\"_blank\"><img width=\"1409\" alt=\"Screen Shot 2016-05-24 at 22.17.27.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/6c091e10-61b3-de55-34b6-6d8fc9181a4f.png\"></a></p>\n\n<p>さて、今回までの4つの記事により、下記が出来るようなりました。</p>\n\n<ul>\n<li>Ethereumのテストネットを動かす</li>\n<li>Boilerplateを使ってSmartContractが記載されたMeteorを動かす</li>\n<li>MeteorとEthereumを接続して動作させる</li>\n<li>MeteorとSmartContractをカスタマイズして独自のアプリケーションを作る</li>\n</ul>\n\n<p>Ethereumやその記述言語であるSolidityはまだまだ仕様が変更していく可能性もありますが、大きな可能性のある技術だと思います。<br>\nこれらを用いてこれまでになかったプロダクトをどんどん開発していきましょう！</p>\n","body":"最終回です。\n\nこれまでの記事\n1. [Boilerplateを使ったDapps(分散型アプリケーション)の作成(1)](http://qiita.com/Y-Mukoyama/items/5d751dc01ea4a45dc850)\n2. [Boilerplateを使ったDapps(分散型アプリケーション)の作成(2)](http://qiita.com/Y-Mukoyama/items/0b0f094683805099213d)\n3. [Boilerplateを使ったDapps(分散型アプリケーション)の作成(3)](http://qiita.com/Y-Mukoyama/items/36586d4b2a7e550bf2e1)\n\n\n最後に\n- Mongoに登録されたコントラクト一覧を表示する機能\n- その契約の詳細を表示する機能\nを実装したいと思います。\n\n\n## 2.契約一覧画面\nMongoDBに登録された契約一覧を呼び出して、一覧表を作成します。\n\n### (1) View\n最終的なコードは下記のようになりました。\n\n```index.html\n<template name=\"components_index\">\n    <!-- 商品一覧パネル -->\n    <div class=\"panel panel-default\">\n        <div class=\"panel-heading\">\n            <h4>契約一覧</h4>\n        </div>\n        <table class=\"table\">\n            <thead>\n                <tr>\n                    <th>商品ID</th>\n                    <th>取引先</th>\n                    <th>想定元本</th>\n                    <th>固定金利</th>\n                    <th>変動金利</th>\n                    <th>自社ポジション</th>\n                    <th>期日</th>\n                    <th>ステータス</th>\n                    <th>契約詳細</th>\n                </tr>\n            </thead>\n            <tbody>\n        {{> contract}}\n    </tbody>\n</table>\n</div>\n</template>\n\n<!-- 上記の{{contract}}に格納 -->\n<template name=\"contract\">\n    <!-- index.js にcontractsのヘルパーを記載することで下記の{{}}内に変数が格納される -->\n    {{#each contracts}}\n      <tr>\n          <td id=\"_id\">{{_id}}</td>\n          <td id=\"client\">{{client}}</td>\n          <td id=\"price\">{{price}}</td>\n          <td id=\"fixed_rate\">{{fixedRate}}</td>\n          <td id=\"floated_rate\">TIBOR + {{spread}}</td>\n          <td id=\"position\">{{position}}</td>\n          <td id=\"expired_date\">{{expiredDate}}</td>\n      {{#if done}}\n          <td><button type=\"button\" class=\"btn btn-success\">実行済</button></td>\n      {{else}}\n          <td><button type=\"button\" class=\"btn btn-default\">未実行</button></td>\n      {{/if}}\n      <td><button type=\"button\" class=\"btn btn-warning\"><a href =\"/contract/{{_id}}\" style=\"color:#fff;\">契約詳細</a></button></td>\n      </tr>\n    {{/each}}\n</template>\n```\n\nMeteorは[Blaze](http://guide.meteor.com/blaze.html)というレンダリングエンジンを仕様しています。\n前回同様、Templateで他のレイアウト側のHTMLファイルから呼び出しを行っています。\ncontractテンプレート(上記コードの後半部分)の `{{ }}` 部分は、(2)で後述するヘルパーから変数を取得しています。\nまた、契約詳細画面へのリンクを、idをURLとして動的に作成するため、\n`<a href =\"/contract/{{_id}}\" style=\"color:#fff;\">契約詳細</a>`\nこのようにリンクを貼っています。\n\n### (2)JSファイル\nこちらは非常にシンプルです。\n\n```index.js\nTemplate.contract.helpers({\n contracts: function(){\n   Meteor.subscribe('contracts');  //serverのcontractsをsubscribeする\n   return Contracts.find();  //main.jsにcontractsの配列を返す\n }\n});\n```\n\ncontractテンプレートに渡す `contracts` という配列をヘルパーとして取得しています。\n`Meteor.subscribe` は、(3)で記載する `publish` とセットにすることで、DB内のコレクションにアクセスすることが可能になります。\n\n\n### (3)サーバー側\n前回のコードに下記を追記します。\n\n```server/main.js\n....\n    Meteor.publish('contracts', function() {  //client側にpublishする\n      return Contracts.find({});  //全ての配列\n    });\n...\n```\n\nこれにより、(2)の `subscribe` で取得可能になります。\n`subscribe` と `public` はセットで使用すると覚えましょう。\n\n### (4)最終形\nこれらのコードにより最終的に下記のような画面が作成されました。\n\n<img width=\"1428\" alt=\"Screen Shot 2016-05-24 at 22.15.01.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/5fb35be8-ede6-2566-20ae-0fc611d12715.png\">\n\nDB内に入っているContractコレクションを一覧として取得して表示しています。\nまた、ステータスはパラメータの値に応じて、ボタンが切り替わる用にViewでif分岐をしています。\nそして、契約詳細ボタンは、各契約の詳細ページに飛ぶリンクとなっています。\n\n\n## 3.契約詳細画面\n動的に生成されたURIから飛ぶ、契約詳細ページを作成します。\n\n### (1)ルーティング\nBoilerplateは、Meteorのルーティング用ライブラリのデファクトスタンダードと言える、「Iron router」を使用しています。\n動的にContractsコレクションのIDでview4というテンプレートにリンクを貼るコードは下記のようになります。\n\n```client/templates/routes.js\nRouter.map(function() {\n  this.route('view4', {\n    path: 'contract/:_id',    //URLの生成\n    data: function() { return Contracts.findOne({_id: this.params._id});}\n  });\n});\n```\n\n最後の行により、`this.params._id` でViewもしくはJS側から _idを取得することが可能になります。\n\n\n### (2)View\n下記抜粋です。2と同じように、JSファイルからヘルパーとして渡された変数を表示するようになっています。\n\n```info.html\n<template name=\"contract_detail\">\n    <tr>\n        <th>商品ID</th>\n        <td>{{_id}}</td>\n    </tr>\n    <tr>\n        <th>契約名</th>\n        <td>{{contract_name}}</td>\n    </tr>\n    <tr>\n        <th>相手企業名</th>\n        <td>{{client_name}}</td>\n    </tr>\n    <tr>\n        <th>自社ポジション</th>\n        <td>{{position}}</td>\n    </tr>\n\n.....略.....\n\n</template>\n```\n\n### (3)JSファイル\n```info.js\nTemplate.contract_detail.helpers({\n   details: function(){\n     Meteor.subscribe('contracts');  //serverのcontractsをsubscribeする\n     return Contracts.findOne({_id: this.params._id});  //info.jsに動的なidで取得したオブジェクトを渡す\n   }\n});\n```\n\n`subscribe`は、2と同じです。\nルーティングファイルからidを取得できるため、コレクションからそのidで検索したオブジェクトをView側に渡しています。\n\n\n### (4)最終形\n下記のような画面が作成されました (開発の都合上、空欄が発生してしまっていますが...) \n\n<img width=\"1409\" alt=\"Screen Shot 2016-05-24 at 22.17.27.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/6c091e10-61b3-de55-34b6-6d8fc9181a4f.png\">\n\n\nさて、今回までの4つの記事により、下記が出来るようなりました。\n\n- Ethereumのテストネットを動かす\n- Boilerplateを使ってSmartContractが記載されたMeteorを動かす\n- MeteorとEthereumを接続して動作させる\n- MeteorとSmartContractをカスタマイズして独自のアプリケーションを作る\n\nEthereumやその記述言語であるSolidityはまだまだ仕様が変更していく可能性もありますが、大きな可能性のある技術だと思います。\nこれらを用いてこれまでになかったプロダクトをどんどん開発していきましょう！\n","coediting":false,"created_at":"2016-05-25T18:32:49+09:00","id":"49f378506dcbb7fb7293","private":false,"tags":[{"name":"Meteor","versions":[]},{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"Boilerplateを使ったDapps(分散型アプリケーション)の作成(4)","updated_at":"2016-05-25T18:36:57+09:00","url":"http://qiita.com/Y-Mukoyama/items/49f378506dcbb7fb7293","user":{"description":"","facebook_id":"yusuke.mukoyama.3","followees_count":2,"followers_count":2,"github_login_name":"YusukeMukoyama","id":"Y-Mukoyama","items_count":19,"linkedin_id":"","location":"Tokyo","name":"Yusuke Mukoyama","organization":"","permanent_id":87650,"profile_image_url":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/87650/721f6204557100b8cccc56e4e67a36f85f3eacf5/medium.png?1450101576","twitter_screen_name":"mukoyam","website_url":""}},{"rendered_body":"<p>続きです。</p>\n\n<ol>\n<li><a href=\"http://qiita.com/Y-Mukoyama/items/5d751dc01ea4a45dc850\" id=\"reference-e5c9d8f678b601c267a9\">Boilerplateを使ったDapps(分散型アプリケーション)の作成(1)</a></li>\n<li><a href=\"http://qiita.com/Y-Mukoyama/items/0b0f094683805099213d\" id=\"reference-23b571841098da62bc1d\">Boilerplateを使ったDapps(分散型アプリケーション)の作成(2)</a></li>\n</ol>\n\n<p>この連載の最後に、ContractやViewを簡単にカスタマイズして、独自のDappを作成してみたいと思います。<br>\nテストネットに接続してマイニング中、MeteorでBoilerplateを起動中、ということを前提とします。<br>\nこの辺りの詳しい話は、第1回と第2回に記載しています。</p>\n\n<h2>\n<span id=\"成果物\" class=\"fragment\"></span><a href=\"#%E6%88%90%E6%9E%9C%E7%89%A9\"><i class=\"fa fa-link\"></i></a>成果物</h2>\n\n<p>今回最終的に目指すのは、下記3つの画面(と機能)を作成することです。</p>\n\n<ol>\n<li>\n<p>契約作成(金利スワップの契約)画面を作成</p>\n\n<ul>\n<li>SmartContractの契約情報をブラウザから入力可能</li>\n<li>MongoDBにも契約情報を保管</li>\n<li>マイニングにより契約がブロックチェーン(テストネット)に埋め込まれる</li>\n<li>マイニングが完了するとContractのアドレスが取得可能になる</li>\n</ul>\n</li>\n<li>\n<p>契約一覧画面</p>\n\n<ul>\n<li>作成した契約のサマリが一覧表として取得できる</li>\n<li>3の契約詳細画面へ動的リンクが貼られる </li>\n</ul>\n</li>\n<li>\n<p>契約詳細画面</p>\n\n<ul>\n<li>登録された商品のIDを動的なURLとして、契約商品の詳細画面を表示する</li>\n</ul>\n</li>\n</ol>\n\n<p>Ethereumだけでなく、Meteorを使ったアプリケーションの基本的な作成の流れも理解出来るようになると思います。</p>\n\n<h2>\n<span id=\"1契約作成画面\" class=\"fragment\"></span><a href=\"#1%E5%A5%91%E7%B4%84%E4%BD%9C%E6%88%90%E7%94%BB%E9%9D%A2\"><i class=\"fa fa-link\"></i></a>1.契約作成画面</h2>\n\n<h3>\n<span id=\"1コントラクトの記載\" class=\"fragment\"></span><a href=\"#1%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%81%AE%E8%A8%98%E8%BC%89\"><i class=\"fa fa-link\"></i></a>(1)コントラクトの記載</h3>\n\n<p><code>client/lib/contracts</code> 以下にコントラクトファイルを作成します。<br>\n<a href=\"http://qiita.com/toshikase/items/34292345ce303eb98166\" id=\"reference-9052308988fb8a5f02da\">この記事</a>を参考にして、コントラクトを記述しました。</p>\n\n<div class=\"code-frame\" data-lang=\"text\">\n<div class=\"code-lang\"><span class=\"bold\">swap_trade.sol</span></div>\n<div class=\"highlight\"><pre>\ncontract SwapTrade{\n    address public fixed_side;\n    address public floated_side;\n    uint public price;\n    uint public expired_date;\n    uint public fixed_rate;\n    uint public spread;\n    function SwapTrade(\n      address _fixed_side,\n      address _floated_side,\n      uint _price,\n      uint _expired_date,\n      uint _fixed_rate,\n      uint _spread\n      ){\n      fixed_side = _fixed_side;\n      floated_side = _floated_side;\n      price = _price;\n      expired_date = _expired_date;\n      fixed_rate = _fixed_rate;\n      spread = _spread;\n    }\n}\n</pre></div>\n</div>\n\n<p>詳細はリンク先の記事の通りですが、Contract名と同名のfunctionはコンストラクタとして機能します。<br>\nなので、上記のコードは、コンストラクタのみですが、一通りの動作を確認するには十分かと思います。<br>\nそれぞれの変数は、契約に最初に登録する数値を設定しています。<br>\n- fixed_side...固定金利サイド<br>\n- floated_side...変動金利サイド<br>\n- price...想定元本<br>\n- expired_date...満期日<br>\n- fixed_rate...固定金利<br>\n- spread...変動金利</p>\n\n<h3>\n<span id=\"2コントラクトの入力部分\" class=\"fragment\"></span><a href=\"#2%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%81%AE%E5%85%A5%E5%8A%9B%E9%83%A8%E5%88%86\"><i class=\"fa fa-link\"></i></a>(2)コントラクトの入力部分</h3>\n\n<p><code>client/templates/components</code> 以下に、契約登録用のhtmlとJSファイルを作成します。<br>\nそれぞれ、 <code>swaptrade.html</code> <code>swaptrade.js</code> とします。<br>\nhtmlファイルに <code>Template['components_swaptrade']</code> という記載をしておくことにより、そのコンポーネントは <code>{{components_swaptrade }}</code> で呼び出せます。</p>\n\n<h3>\n<span id=\"3実際のコード\" class=\"fragment\"></span><a href=\"#3%E5%AE%9F%E9%9A%9B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89\"><i class=\"fa fa-link\"></i></a>(3)実際のコード</h3>\n\n<p>そして、 <code>swaptrade.js</code> は下記のように記述をしました。<br>\nconditionsクラスのsubmitをイベントとしたfunctionを作成しています。<br>\nMongoDBへの保存も行っています。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">swaptrade.js</span></div>\n<div class=\"highlight\"><pre>\n  <span class=\"s2\">\"submit .conditions\"</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">,</span> <span class=\"nx\">template</span><span class=\"p\">){</span> <span class=\"c1\">// Create Contract</span>\n    <span class=\"nx\">TemplateVar</span><span class=\"p\">.</span><span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"s1\">'state'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"nx\">isMining</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">});</span>\n    <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">preventDefault</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// Set coinbase as the default account</span>\n    <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">defaultAccount</span> <span class=\"o\">=</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">coinbase</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// Get Abi definition</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">abi</span> <span class=\"o\">=</span> <span class=\"nx\">SwapTrade</span><span class=\"p\">.</span><span class=\"nx\">abi</span>\n\n    <span class=\"c1\">// assemble the tx object w/ default gas value</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">transactionObject</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"nx\">SwapTrade</span><span class=\"p\">.</span><span class=\"nx\">bytecode</span><span class=\"p\">,</span>\n      <span class=\"nx\">gasPrice</span><span class=\"o\">:</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">gasPrice</span><span class=\"p\">,</span>\n      <span class=\"nx\">gas</span><span class=\"o\">:</span> <span class=\"mi\">5000000</span><span class=\"p\">,</span>\n      <span class=\"nx\">from</span><span class=\"o\">:</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">accounts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">};</span>\n\n    <span class=\"kd\">var</span> <span class=\"nx\">position</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">position</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">position</span>  <span class=\"o\">==</span> <span class=\"s2\">\"fixed\"</span> <span class=\"p\">){</span>\n      <span class=\"kd\">var</span> <span class=\"nx\">fixedSide</span> <span class=\"o\">=</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">accounts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n      <span class=\"kd\">var</span> <span class=\"nx\">floatedSide</span> <span class=\"o\">=</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">accounts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n      <span class=\"kd\">var</span> <span class=\"nx\">fixedSide</span> <span class=\"o\">=</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">accounts</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n      <span class=\"kd\">var</span> <span class=\"nx\">floatedSide</span> <span class=\"o\">=</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">accounts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kd\">var</span> <span class=\"nx\">client</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">client</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">price</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">price</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">issuedYear</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">issuedYear</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">issuedMonth</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">issuedMonth</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">issuedDay</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">issuedDay</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">expiredYear</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">expiredYear</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">expiredMonth</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">expiredMonth</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">expiredDay</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">expiredDay</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">fixedRate</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">fixedRate</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">spread</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">spread</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">issuedDate</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Date</span><span class=\"p\">(</span><span class=\"nx\">issuedDay</span> <span class=\"o\">+</span> <span class=\"s2\">\"/\"</span> <span class=\"o\">+</span> <span class=\"nx\">issuedMonth</span> <span class=\"o\">+</span> <span class=\"s2\">\"/\"</span> <span class=\"o\">+</span> <span class=\"nx\">issuedYear</span><span class=\"p\">);</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">parseIssuedDate</span> <span class=\"o\">=</span> <span class=\"nb\">Date</span><span class=\"p\">.</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"nx\">issuedDate</span><span class=\"p\">);</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">expiredDate</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Date</span><span class=\"p\">(</span><span class=\"nx\">expiredDay</span> <span class=\"o\">+</span> <span class=\"s2\">\"/\"</span> <span class=\"o\">+</span> <span class=\"nx\">expiredMonth</span> <span class=\"o\">+</span> <span class=\"s2\">\"/\"</span> <span class=\"o\">+</span> <span class=\"nx\">expiredYear</span><span class=\"p\">);</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">parseExpiredDate</span> <span class=\"o\">=</span> <span class=\"nb\">Date</span><span class=\"p\">.</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"nx\">expiredDate</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// estimate gas cost then transact new SwapTrade</span>\n    <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">estimateGas</span><span class=\"p\">(</span><span class=\"nx\">transactionObject</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">estimateGas</span><span class=\"p\">){</span>\n      <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">err</span><span class=\"p\">)</span>\n      <span class=\"nx\">transactionObject</span><span class=\"p\">.</span><span class=\"nx\">gas</span> <span class=\"o\">=</span> <span class=\"nx\">estimateGas</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n\n      <span class=\"nx\">SwapTrade</span><span class=\"p\">.</span><span class=\"k\">new</span><span class=\"p\">(</span><span class=\"nx\">fixedSide</span><span class=\"p\">,</span> <span class=\"nx\">floatedSide</span><span class=\"p\">,</span> <span class=\"nx\">price</span><span class=\"p\">,</span> <span class=\"nx\">parseExpiredDate</span><span class=\"p\">,</span> <span class=\"nx\">fixedRate</span><span class=\"p\">,</span> <span class=\"nx\">spread</span><span class=\"p\">,</span> <span class=\"nx\">transactionObject</span><span class=\"p\">,</span>\n        <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">contract</span><span class=\"p\">){</span>\n          <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)</span>\n          <span class=\"k\">return</span> <span class=\"nx\">TemplateVar</span><span class=\"p\">.</span><span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"nx\">template</span><span class=\"p\">,</span> <span class=\"s1\">'state'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"nx\">isError</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nx\">error</span><span class=\"o\">:</span> <span class=\"nb\">String</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)});</span>\n\n          <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">contract</span><span class=\"p\">.</span><span class=\"nx\">address</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nx\">TemplateVar</span><span class=\"p\">.</span><span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"nx\">template</span><span class=\"p\">,</span> <span class=\"s1\">'state'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"nx\">isMined</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nx\">address</span><span class=\"o\">:</span> <span class=\"nx\">contract</span><span class=\"p\">.</span><span class=\"nx\">address</span><span class=\"p\">,</span> <span class=\"nx\">source</span><span class=\"o\">:</span> <span class=\"nx\">source</span><span class=\"p\">});</span>\n            <span class=\"nx\">contractInstance</span> <span class=\"o\">=</span> <span class=\"nx\">contract</span><span class=\"p\">;</span>\n            <span class=\"kd\">var</span> <span class=\"nx\">contract_address</span> <span class=\"o\">=</span> <span class=\"nx\">contract</span><span class=\"p\">.</span><span class=\"nx\">address</span><span class=\"p\">;</span>\n\n            <span class=\"c1\">//Mongoにコントラクト情報を保存</span>\n            <span class=\"nx\">Meteor</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"s1\">'insert_contracts'</span><span class=\"p\">,</span> <span class=\"nx\">issuedDate</span><span class=\"p\">,</span> <span class=\"nx\">expiredDate</span><span class=\"p\">,</span> <span class=\"nx\">client</span><span class=\"p\">,</span> <span class=\"nx\">position</span><span class=\"p\">,</span> <span class=\"nx\">fixedSide</span><span class=\"p\">,</span> <span class=\"nx\">floatedSide</span><span class=\"p\">,</span> <span class=\"nx\">price</span><span class=\"p\">,</span>  <span class=\"nx\">fixedRate</span><span class=\"p\">,</span> <span class=\"nx\">spread</span><span class=\"p\">,</span> <span class=\"nx\">contract_address</span><span class=\"p\">,</span> <span class=\"nx\">abi</span><span class=\"p\">);</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">});</span>\n      <span class=\"p\">});</span>\n    <span class=\"p\">},</span>\n</pre></div>\n</div>\n\n<p>web3というgethのJavaScript APIを用いているため、 <code>web3</code> でgethを操作することが出来ます。<br>\n詳細は公式のWikiを読んでもらえればと思いますが、例えば、 <code>web3.eth.coinbase</code> で、接続しているテストネットのCoinbase(メインとなるアカウント = 自分で設定出来ます)が取り出せたりします。</p>\n\n<p>また、SwapTradeというオブジェクトは、上記で記載した <code>.sol</code> ファイルから作成されています。<br>\nBoilerplateでは、自動的にcontractsファイルで記載した <code>.sol</code> ファイルをオブジェクトとして利用出来るようになります。<br>\nこれが非常に便利です。</p>\n\n<p>「abi」(application binary interface)というのは、ざっくり捉えると「バイナリ化されたAPI」ぐらいに考えていただければ大丈夫だと思います。</p>\n\n<p><code>transactionObject</code> に格納しているのはコントラクトを送る際のオプションです。<br>\ngasとはマイニングした人に送られる報酬であり、gasが少なすぎるといつまでたってもマイニングがされず、トランザクションが実行されない、ということになってしまいます。<br>\nここでは、5000000に設定しています。</p>\n\n<p><code>event.target</code> で取得している変数群は、フォームから入力された値を取得してきています。</p>\n\n<p>そして、 <code>SwapTrade.new(....)</code> の部分がコントラクトをトランザクションする記述です。<br>\nオブジェクトにnewするだけで、コンストラクタを含めたコントラクトを簡単にブロックチェーンに送ることが出来ます。</p>\n\n<p>同時に <code>Meteor.call(....)</code> の部分でMongoDBにデータを格納しています。<br>\n今回は、サーバー側で定義した <code>insert_contracts</code> メソッドを呼び出していて、これは(5)で説明します。<br>\n<code>Meteor.call</code> することで、定義したメソッドを呼び出すことができます。</p>\n\n<h3>\n<span id=\"4-コレクションの定義\" class=\"fragment\"></span><a href=\"#4-%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%AE%9A%E7%BE%A9\"><i class=\"fa fa-link\"></i></a>(4) コレクションの定義</h3>\n\n<p>Mongoで扱うデータはコレクションとしてオブジェクト化することで使えるようになります。<br>\n<code>lib/collections.js</code> というファイルを作成して、そこで下記のように書いておきます。<br>\nそうすることにより <code>Contracts</code> というオブジェクトをインスタンス化し、メソッドでDBにアクセス出来ます。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">collection.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nx\">Contracts</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Mongo</span><span class=\"p\">.</span><span class=\"nx\">Collection</span><span class=\"p\">(</span><span class=\"s1\">'contracts'</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n\n<h3>\n<span id=\"5-サーバー側の変数定義\" class=\"fragment\"></span><a href=\"#5-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E5%81%B4%E3%81%AE%E5%A4%89%E6%95%B0%E5%AE%9A%E7%BE%A9\"><i class=\"fa fa-link\"></i></a>(5) サーバー側の変数定義</h3>\n\n<p>クライアントから呼び出せるような <code>insert_contracts</code> メソッドをサーバーで定義します。<br>\nコードは下記の通りです。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">client/main.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">Meteor</span><span class=\"p\">.</span><span class=\"nx\">isServer</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">Meteor</span><span class=\"p\">.</span><span class=\"nx\">startup</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">Meteor</span><span class=\"p\">.</span><span class=\"nx\">methods</span><span class=\"p\">({</span>\n      <span class=\"s1\">'insert_contracts'</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">issuedDate</span><span class=\"p\">,</span> <span class=\"nx\">expiredDate</span><span class=\"p\">,</span> <span class=\"nx\">client</span><span class=\"p\">,</span> <span class=\"nx\">position</span><span class=\"p\">,</span> <span class=\"nx\">fixedSide</span><span class=\"p\">,</span> <span class=\"nx\">floatedSide</span><span class=\"p\">,</span> <span class=\"nx\">price</span><span class=\"p\">,</span> <span class=\"nx\">fixedRate</span><span class=\"p\">,</span> <span class=\"nx\">spread</span><span class=\"p\">,</span> <span class=\"nx\">contract_address</span><span class=\"p\">,</span> <span class=\"nx\">abi</span><span class=\"p\">){</span>\n        <span class=\"nx\">Contracts</span><span class=\"p\">.</span><span class=\"nx\">insert</span><span class=\"p\">({</span>\n          <span class=\"nx\">issuedDate</span><span class=\"o\">:</span> <span class=\"nx\">issuedDate</span><span class=\"p\">,</span>\n          <span class=\"nx\">expiredDate</span><span class=\"o\">:</span> <span class=\"nx\">expiredDate</span><span class=\"p\">,</span>\n          <span class=\"nx\">client</span><span class=\"o\">:</span> <span class=\"nx\">client</span><span class=\"p\">,</span>\n          <span class=\"nx\">position</span><span class=\"o\">:</span> <span class=\"nx\">position</span><span class=\"p\">,</span>\n          <span class=\"nx\">fixedSide</span><span class=\"o\">:</span> <span class=\"nx\">fixedSide</span><span class=\"p\">,</span>\n          <span class=\"nx\">floatedSide</span><span class=\"o\">:</span> <span class=\"nx\">floatedSide</span><span class=\"p\">,</span>\n          <span class=\"nx\">price</span><span class=\"o\">:</span> <span class=\"nx\">price</span><span class=\"p\">,</span>\n          <span class=\"nx\">fixedRate</span><span class=\"o\">:</span> <span class=\"nx\">fixedRate</span><span class=\"p\">,</span>\n          <span class=\"nx\">spread</span><span class=\"o\">:</span> <span class=\"nx\">spread</span><span class=\"p\">,</span>\n          <span class=\"nx\">contract_address</span><span class=\"o\">:</span> <span class=\"nx\">contract_address</span><span class=\"p\">,</span>\n          <span class=\"nx\">abi</span><span class=\"o\">:</span> <span class=\"nx\">abi</span><span class=\"p\">,</span>\n        <span class=\"p\">});</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">});</span>\n<span class=\"p\">};</span>\n</pre></div>\n</div>\n\n<p>わざわざ複数ファイルに分けるほど、多くサーバー側にコードを書かないため、 <code>server/main.js</code> にまとめて記載します。<br>\n- <code>if (Meteor.isServer)</code> の記述によりサーバー側のコードと明示します<br>\n- <code>Meteor.startup</code> で、常に使えるfunctionを定義します<br>\n- あとは、 <code>insert_contract</code> で引数と、 (4)で作成したContractsオブジェクトにより新規データをMongoに格納しています。</p>\n\n<h3>\n<span id=\"6最終形\" class=\"fragment\"></span><a href=\"#6%E6%9C%80%E7%B5%82%E5%BD%A2\"><i class=\"fa fa-link\"></i></a>(6)最終形</h3>\n\n<p>最終的には、下記のような画面を作成しました。<br>\n<a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/9decdef6-d91f-7b89-970b-99454883ea9d.png\" target=\"_blank\"><img width=\"1423\" alt=\"Screen Shot 2016-05-24 at 22.08.55.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/9decdef6-d91f-7b89-970b-99454883ea9d.png\"></a></p>\n\n<p>作成するボタンを押すことで、マイニング待ちの状態になります。<br>\n同時にMongoDBにもデータを格納しています。<br>\n<a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/acc3c315-a451-27e3-d168-5e68dbc6fc73.png\" target=\"_blank\"><img width=\"786\" alt=\"Screen Shot 2016-05-24 at 22.10.49.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/acc3c315-a451-27e3-d168-5e68dbc6fc73.png\"></a></p>\n\n<p>マイニングが完了することで、アドレスが発行されました<br>\n<a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/e8707dd6-13b6-f31b-c2a2-e75e0340fd6a.png\" target=\"_blank\"><img width=\"698\" alt=\"Screen Shot 2016-05-24 at 22.11.31.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/e8707dd6-13b6-f31b-c2a2-e75e0340fd6a.png\"></a></p>\n\n<p>これで契約作成画面は完成です。</p>\n\n<p>次回でいよいよ最終回です。<br>\n最後に、格納したデータを一覧としてみる、そのデータから動的に作成されたURLで詳細ページにアクセスする、という機能を実装していきます。</p>\n","body":"続きです。\n\n1. [Boilerplateを使ったDapps(分散型アプリケーション)の作成(1)](http://qiita.com/Y-Mukoyama/items/5d751dc01ea4a45dc850)\n2. [Boilerplateを使ったDapps(分散型アプリケーション)の作成(2)](http://qiita.com/Y-Mukoyama/items/0b0f094683805099213d)\n\nこの連載の最後に、ContractやViewを簡単にカスタマイズして、独自のDappを作成してみたいと思います。\nテストネットに接続してマイニング中、MeteorでBoilerplateを起動中、ということを前提とします。\nこの辺りの詳しい話は、第1回と第2回に記載しています。\n\n## 成果物\n今回最終的に目指すのは、下記3つの画面(と機能)を作成することです。\n\n\n\n1. 契約作成(金利スワップの契約)画面を作成\n - SmartContractの契約情報をブラウザから入力可能\n - MongoDBにも契約情報を保管\n - マイニングにより契約がブロックチェーン(テストネット)に埋め込まれる\n - マイニングが完了するとContractのアドレスが取得可能になる\n\n2. 契約一覧画面\n - 作成した契約のサマリが一覧表として取得できる\n - 3の契約詳細画面へ動的リンクが貼られる \n\n3. 契約詳細画面\n - 登録された商品のIDを動的なURLとして、契約商品の詳細画面を表示する\n\nEthereumだけでなく、Meteorを使ったアプリケーションの基本的な作成の流れも理解出来るようになると思います。\n\n##  1.契約作成画面\n### (1)コントラクトの記載\n`client/lib/contracts` 以下にコントラクトファイルを作成します。\n[この記事](http://qiita.com/toshikase/items/34292345ce303eb98166)を参考にして、コントラクトを記述しました。\n\n```swap_trade.sol\ncontract SwapTrade{\n    address public fixed_side;\n    address public floated_side;\n    uint public price;\n    uint public expired_date;\n    uint public fixed_rate;\n    uint public spread;\n    function SwapTrade(\n      address _fixed_side,\n      address _floated_side,\n      uint _price,\n      uint _expired_date,\n      uint _fixed_rate,\n      uint _spread\n      ){\n      fixed_side = _fixed_side;\n      floated_side = _floated_side;\n      price = _price;\n      expired_date = _expired_date;\n      fixed_rate = _fixed_rate;\n      spread = _spread;\n    }\n}\n```\n\n詳細はリンク先の記事の通りですが、Contract名と同名のfunctionはコンストラクタとして機能します。\nなので、上記のコードは、コンストラクタのみですが、一通りの動作を確認するには十分かと思います。\nそれぞれの変数は、契約に最初に登録する数値を設定しています。\n- fixed_side...固定金利サイド\n- floated_side...変動金利サイド\n- price...想定元本\n- expired_date...満期日\n- fixed_rate...固定金利\n- spread...変動金利\n\n### (2)コントラクトの入力部分\n`client/templates/components` 以下に、契約登録用のhtmlとJSファイルを作成します。\nそれぞれ、 `swaptrade.html` `swaptrade.js` とします。\nhtmlファイルに `Template['components_swaptrade']` という記載をしておくことにより、そのコンポーネントは `{{components_swaptrade }}` で呼び出せます。\n\n\n### (3)実際のコード\nそして、 `swaptrade.js` は下記のように記述をしました。\nconditionsクラスのsubmitをイベントとしたfunctionを作成しています。\nMongoDBへの保存も行っています。\n\n```swaptrade.js\n  \"submit .conditions\": function(event, template){ // Create Contract\n    TemplateVar.set('state', {isMining: true});\n    event.preventDefault();\n\n    // Set coinbase as the default account\n    web3.eth.defaultAccount = web3.eth.coinbase;\n\n    // Get Abi definition\n    var abi = SwapTrade.abi\n\n    // assemble the tx object w/ default gas value\n    var transactionObject = {\n      data: SwapTrade.bytecode,\n      gasPrice: web3.eth.gasPrice,\n      gas: 5000000,\n      from: web3.eth.accounts[0]\n    };\n\n    var position = event.target.position.value;\n    if (position  == \"fixed\" ){\n      var fixedSide = web3.eth.accounts[0];\n      var floatedSide = web3.eth.accounts[1];\n\n    } else {\n      var fixedSide = web3.eth.accounts[1];\n      var floatedSide = web3.eth.accounts[0];\n    }\n\n    var client = event.target.client.value;\n    var price = event.target.price.value;\n    var issuedYear = event.target.issuedYear.value;\n    var issuedMonth = event.target.issuedMonth.value;\n    var issuedDay = event.target.issuedDay.value;\n    var expiredYear = event.target.expiredYear.value;\n    var expiredMonth = event.target.expiredMonth.value;\n    var expiredDay = event.target.expiredDay.value;\n    var fixedRate = event.target.fixedRate.value;\n    var spread = event.target.spread.value;\n    var issuedDate = new Date(issuedDay + \"/\" + issuedMonth + \"/\" + issuedYear);\n    var parseIssuedDate = Date.parse(issuedDate);\n    var expiredDate = new Date(expiredDay + \"/\" + expiredMonth + \"/\" + expiredYear);\n    var parseExpiredDate = Date.parse(expiredDate);\n\n    // estimate gas cost then transact new SwapTrade\n    web3.eth.estimateGas(transactionObject, function(err, estimateGas){\n      if(!err)\n      transactionObject.gas = estimateGas * 10;\n\n      SwapTrade.new(fixedSide, floatedSide, price, parseExpiredDate, fixedRate, spread, transactionObject,\n        function(err, contract){\n          if(err)\n          return TemplateVar.set(template, 'state', {isError: true, error: String(err)});\n\n          if(contract.address) {\n            TemplateVar.set(template, 'state', {isMined: true, address: contract.address, source: source});\n            contractInstance = contract;\n            var contract_address = contract.address;\n\n            //Mongoにコントラクト情報を保存\n            Meteor.call('insert_contracts', issuedDate, expiredDate, client, position, fixedSide, floatedSide, price,  fixedRate, spread, contract_address, abi);\n          }\n        });\n      });\n    },\n```\n\nweb3というgethのJavaScript APIを用いているため、 `web3` でgethを操作することが出来ます。\n詳細は公式のWikiを読んでもらえればと思いますが、例えば、 `web3.eth.coinbase` で、接続しているテストネットのCoinbase(メインとなるアカウント = 自分で設定出来ます)が取り出せたりします。\n\nまた、SwapTradeというオブジェクトは、上記で記載した `.sol` ファイルから作成されています。\nBoilerplateでは、自動的にcontractsファイルで記載した `.sol` ファイルをオブジェクトとして利用出来るようになります。\nこれが非常に便利です。\n\n「abi」(application binary interface)というのは、ざっくり捉えると「バイナリ化されたAPI」ぐらいに考えていただければ大丈夫だと思います。\n\n`transactionObject` に格納しているのはコントラクトを送る際のオプションです。\ngasとはマイニングした人に送られる報酬であり、gasが少なすぎるといつまでたってもマイニングがされず、トランザクションが実行されない、ということになってしまいます。\nここでは、5000000に設定しています。\n\n`event.target` で取得している変数群は、フォームから入力された値を取得してきています。\n\nそして、 `SwapTrade.new(....)` の部分がコントラクトをトランザクションする記述です。\nオブジェクトにnewするだけで、コンストラクタを含めたコントラクトを簡単にブロックチェーンに送ることが出来ます。\n\n同時に `Meteor.call(....)` の部分でMongoDBにデータを格納しています。\n今回は、サーバー側で定義した `insert_contracts` メソッドを呼び出していて、これは(5)で説明します。\n`Meteor.call` することで、定義したメソッドを呼び出すことができます。\n\n### (4) コレクションの定義\nMongoで扱うデータはコレクションとしてオブジェクト化することで使えるようになります。\n`lib/collections.js` というファイルを作成して、そこで下記のように書いておきます。\nそうすることにより `Contracts` というオブジェクトをインスタンス化し、メソッドでDBにアクセス出来ます。\n\n```collection.js\nContracts = new Mongo.Collection('contracts');\n```\n\n### (5) サーバー側の変数定義\nクライアントから呼び出せるような `insert_contracts` メソッドをサーバーで定義します。\nコードは下記の通りです。\n\n```client/main.js\nif (Meteor.isServer) {\n  Meteor.startup(function () {\n    Meteor.methods({\n      'insert_contracts': function(issuedDate, expiredDate, client, position, fixedSide, floatedSide, price, fixedRate, spread, contract_address, abi){\n        Contracts.insert({\n          issuedDate: issuedDate,\n          expiredDate: expiredDate,\n          client: client,\n          position: position,\n          fixedSide: fixedSide,\n          floatedSide: floatedSide,\n          price: price,\n          fixedRate: fixedRate,\n          spread: spread,\n          contract_address: contract_address,\n          abi: abi,\n        });\n      }\n    });\n  });\n};\n```\n\nわざわざ複数ファイルに分けるほど、多くサーバー側にコードを書かないため、 `server/main.js` にまとめて記載します。\n- `if (Meteor.isServer)` の記述によりサーバー側のコードと明示します\n- `Meteor.startup` で、常に使えるfunctionを定義します\n- あとは、 `insert_contract` で引数と、 (4)で作成したContractsオブジェクトにより新規データをMongoに格納しています。\n\n### (6)最終形\n最終的には、下記のような画面を作成しました。\n<img width=\"1423\" alt=\"Screen Shot 2016-05-24 at 22.08.55.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/9decdef6-d91f-7b89-970b-99454883ea9d.png\">\n\n\n作成するボタンを押すことで、マイニング待ちの状態になります。\n同時にMongoDBにもデータを格納しています。\n<img width=\"786\" alt=\"Screen Shot 2016-05-24 at 22.10.49.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/acc3c315-a451-27e3-d168-5e68dbc6fc73.png\">\n\nマイニングが完了することで、アドレスが発行されました\n<img width=\"698\" alt=\"Screen Shot 2016-05-24 at 22.11.31.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/e8707dd6-13b6-f31b-c2a2-e75e0340fd6a.png\">\n\nこれで契約作成画面は完成です。\n\n次回でいよいよ最終回です。\n最後に、格納したデータを一覧としてみる、そのデータから動的に作成されたURLで詳細ページにアクセスする、という機能を実装していきます。\n","coediting":false,"created_at":"2016-05-25T01:07:29+09:00","id":"36586d4b2a7e550bf2e1","private":false,"tags":[{"name":"Meteor","versions":[]},{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"Boilerplateを使ったDapps(分散型アプリケーション)の作成(3)","updated_at":"2016-05-25T18:33:11+09:00","url":"http://qiita.com/Y-Mukoyama/items/36586d4b2a7e550bf2e1","user":{"description":"","facebook_id":"yusuke.mukoyama.3","followees_count":2,"followers_count":2,"github_login_name":"YusukeMukoyama","id":"Y-Mukoyama","items_count":19,"linkedin_id":"","location":"Tokyo","name":"Yusuke Mukoyama","organization":"","permanent_id":87650,"profile_image_url":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/87650/721f6204557100b8cccc56e4e67a36f85f3eacf5/medium.png?1450101576","twitter_screen_name":"mukoyam","website_url":""}},{"rendered_body":"<p><a href=\"http://qiita.com/toshikase/items/467f8998506a2f0cf258\" id=\"reference-e70db4e3d833649afe12\">前回</a>はオプション取引の実装方法をご紹介しました。今回は同じ要領でスワップ取引を実装しましょう。</p>\n\n<h2>\n<span id=\"コントラクト概要\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E6%A6%82%E8%A6%81\"><i class=\"fa fa-link\"></i></a>コントラクト概要</h2>\n\n<p>今回は金利スワップを実装します。金利スワップとは同一通貨間で異なる種類の金利を交換する取引のことです。最も多い取引は固定金利と変動金利の交換です。<br>\n例えば円の金利スワップでは、固定金利と6ヵ月<a href=\"http://www.ifinance.ne.jp/glossary/market/mar006.html\">TIBOR</a>とを半年毎に交換する取引などがあります。</p>\n\n<p>今回実装する取引の設定は以下の通りです。</p>\n\n<p><strong>基本情報</strong></p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left\">key</th>\n<th style=\"text-align: left\">value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left\">通貨</td>\n<td style=\"text-align: left\">ether(≒¥1,000)</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">想定元本</td>\n<td style=\"text-align: left\">1,000</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">デポジット</td>\n<td style=\"text-align: left\">100</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">満期日</td>\n<td style=\"text-align: left\">契約日から2年後</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">受渡サイクル</td>\n<td style=\"text-align: left\">1ヶ月</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">変動金利(支払)</td>\n<td style=\"text-align: left\">0xc12b4d335ce5f0cf48001c8b06e1f941edb68e9d</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">固定金利(支払)</td>\n<td style=\"text-align: left\">0xbc2ee815f7115c3d7cd1bc389fcb9b4f93c52830</td>\n</tr>\n</tbody>\n</table>\n\n<p><strong>変動金利</strong></p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left\">key</th>\n<th style=\"text-align: left\">value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left\">基準金利</td>\n<td style=\"text-align: left\">1%</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">スプレッド</td>\n<td style=\"text-align: left\">2%</td>\n</tr>\n</tbody>\n</table>\n\n<p><strong>固定金利</strong></p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left\">key</th>\n<th style=\"text-align: left\">value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left\">基準金利</td>\n<td style=\"text-align: left\">--</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">スプレッド</td>\n<td style=\"text-align: left\">4%</td>\n</tr>\n</tbody>\n</table>\n\n<p>以下が完成形のコードです</p>\n\n<div class=\"code-frame\" data-lang=\"text\">\n<div class=\"code-lang\"><span class=\"bold\">swap_trade.sol</span></div>\n<div class=\"highlight\"><pre>\ncontract SwapTrade{\n    address public fixed_side;\n    address public floated_side;\n    uint public capital;\n    uint public fixed_rate;\n    uint public spread;\n    function SwapTrade(\n      address _fixed_side,\n      address _floated_side,\n      uint _capital,\n      uint _fixed_rate,\n      uint _spread\n      ){\n      fixed_side = _fixed_side;\n      floated_side = _floated_side;\n      capital = _capital;\n      fixed_rate = _fixed_rate;\n      spread = _spread;\n    }\n    function Execution(uint floating_rate){\n      floated_side.send(capital*fixed_rate);\n      fixed_side.send(capital*(floating_rate+spread));\n    }\n    function () {\n      throw;\n    }\n}\n</pre></div>\n</div>\n\n<ul>\n<li>SwapTrade：初期化</li>\n<li>Execution：利息支払実行</li>\n</ul>\n\n<h2>\n<span id=\"コントラクト登録\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E7%99%BB%E9%8C%B2\"><i class=\"fa fa-link\"></i></a>コントラクト登録</h2>\n\n<p>まずコードをコンパイルします。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; var source = \"contract SwapTrade{    address public fixed_side;    address public floated_side;    uint public capital;    uint public fixed_rate;    uint public spread;    function SwapTrade(      address _fixed_side,      address _floated_side,      uint _capital,      uint _fixed_rate,      uint _spread      ){      fixed_side = _fixed_side;      floated_side = _floated_side;      capital = _capital;      fixed_rate = _fixed_rate;      spread = _spread;    }    function Execution(uint floating_rate){      floated_side.send(capital*fixed_rate);      fixed_side.send(capital*(floating_rate+spread));    }    function () {      throw;    }}\"\n&gt; var compiledSource = eth.compile.solidity(source)\n</pre></div></div>\n\n<p>続いて、コントラクトをEthereumのネットワークに送信します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; var abiDefinition = compiledSource.SwapTrade.info.abiDefinition\n&gt; var compiledContract = eth.contract(abiDefinition)\n&gt; var fixedSide = \"0xc12b4d335ce5f0cf48001c8b06e1f941edb68e9d\"\n&gt; var floatedSide = \"0xbc2ee815f7115c3d7cd1bc389fcb9b4f93c52830\"\n&gt; var contract = compiledContract.new(fixedSide, floatedSide, 10*1.0e+18, 4, 2, {from: fixedSide, data: compiledSource.SwapTrade.code, gas:1000000, value: web3.toWei(100,\"ether\")})\n</pre></div></div>\n\n<p>ここで、<code>fixedSide</code>は変動金利を支払うアドレス、<code>floatedSide</code>は固定金利を支払うアドレスです。<br>\n<code>10*1.0e+18</code>,<code>4</code>,<code>2</code>はそれぞれ想定元本、固定金利、スプレッドを表しています。solidityでは浮動小数点は扱えないので、想定元本を1/100しています。(その後、単位をweiからetherに変更するため、10e+18倍しています。) 固定金利とスプレッドは100倍しています。<br>\nまた <code>value: web3.toWei(100,\"ether\")</code> でfixedSideからこのアカウントに100etherデポジットしています。</p>\n\n<p>以下のようにコントラクトが送信されました。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract\n{\n  address: undefined,\n  transactionHash: \"0x3b0a5a32f549bec31bcf173274a344add2f319b9de0367071392e3fd9717ce07\"\n}\n&gt; web3.fromWei(eth.getBalance(\"0x4934f96cbb5f82ead8d56f96ec11f98c826cc926\"),\"ether\")\n0\n&gt; web3.fromWei(eth.getBalance(fixesSide),\"ether\")\n959.972328980000000030\n</pre></div></div>\n\n<p>この状態ではコントラクトの残高は0です。</p>\n\n<p>続いてマイニングを行います。マイニングが完了すると以下のようになります。アドレスが付与されるているのがわかります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract\n{\n  address: \"0x4934f96cbb5f82ead8d56f96ec11f98c826cc926\",\n  transactionHash: \"0x3b0a5a32f549bec31bcf173274a344add2f319b9de0367071392e3fd9717ce07\",\n  Execution: function(),\n  allEvents: function(),\n  capital: function(),\n  fixed_rate: function(),\n  fixed_side: function(),\n  floated_side: function(),\n  spread: function()\n}\n</pre></div></div>\n\n<p>またコントラクトの残高がデポジット分変化しているのがわかります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; web3.fromWei(eth.getBalance(\"0x4934f96cbb5f82ead8d56f96ec11f98c826cc926\"),\"ether\")\n100\n&gt; web3.fromWei(eth.getBalance(fixesSide),\"ether\")\n859.96823490000000003\n</pre></div></div>\n\n<p>(本来であれば、この後floatedSideからも100etherデポジットする必要があるのですが、今回はその手続は省いて先に進みます。)</p>\n\n<h2>\n<span id=\"executionメソッド\" class=\"fragment\"></span><a href=\"#execution%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89\"><i class=\"fa fa-link\"></i></a>Executionメソッド</h2>\n\n<p>初期化が完了しました。続いて1ヶ月がたった前提でExecutionメソッドを実行しましょう。<br>\nこれは支払日に利息の支払いを実効するメソッドです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nfunction Execution(uint floating_rate){\n     floated_side.send(capital*fixed_rate);\n     fixed_side.send(capital*(floating_rate+spread));\n}\n</pre></div></div>\n\n<p>メソッドを呼び出しましょう。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.Execution.sendTransaction(1, {from: fixedSide, gas:1000000})\n</pre></div></div>\n\n<p>マイニング前の両者のether残高です。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; web3.fromWei(eth.getBalance(fixedSide),\"ether\")\n859.96823490000000003\n&gt; web3.fromWei(eth.getBalance(floatedSide),\"ether\")\n1439.96000000000000004\n</pre></div></div>\n\n<p>マイニング完了後は以下のように残高が変化します。利息分だけ両者の残高が増えているのがわかります。</p>\n\n<p>fixedSideは変動金利を受け取るので30ether増えます。<br>\n変動金利：1000×(0.01+0.02) = 30</p>\n\n<p>floatedSideは固定金利を受け取るので40ether増えます。<br>\n固定金利：1000×0.04 = 40</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; web3.fromWei(eth.getBalance(fixedSide),\"ether\")\n889.96752358000000003\n&gt; web3.fromWei(eth.getBalance(floatedSide),\"ether\")\n1479.96000000000000004\n</pre></div></div>\n\n<p>実際に増えていますね。</p>\n\n<h2>\n<span id=\"まとめ\" class=\"fragment\"></span><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"><i class=\"fa fa-link\"></i></a>まとめ</h2>\n\n<p>今回まで3回に渡りSolidityを用いたコントラクトの開発方法について綴ってきました。<br>\nこれを機に皆様がEthereumに興味を持ってくだされば幸いです。また何かあればいつでもご質問・ご連絡ください。</p>\n","body":"[前回](http://qiita.com/toshikase/items/467f8998506a2f0cf258)はオプション取引の実装方法をご紹介しました。今回は同じ要領でスワップ取引を実装しましょう。\n\n##コントラクト概要\n今回は金利スワップを実装します。金利スワップとは同一通貨間で異なる種類の金利を交換する取引のことです。最も多い取引は固定金利と変動金利の交換です。\n例えば円の金利スワップでは、固定金利と6ヵ月[TIBOR](http://www.ifinance.ne.jp/glossary/market/mar006.html)とを半年毎に交換する取引などがあります。\n\n今回実装する取引の設定は以下の通りです。\n\n**基本情報**\n\n| key | value | \n|:----------|:-----------|\n| 通貨 | ether(≒¥1,000) |\n| 想定元本 | 1,000 | \n| デポジット |100 | \n| 満期日 | 契約日から2年後 |\n| 受渡サイクル | 1ヶ月 | \n| 変動金利(支払) |  0xc12b4d335ce5f0cf48001c8b06e1f941edb68e9d | \n| 固定金利(支払) | 0xbc2ee815f7115c3d7cd1bc389fcb9b4f93c52830 |  \n \n**変動金利**\n\n| key | value | \n|:----------|:-----------|\n| 基準金利 | 1% |\n| スプレッド | 2% |\n\n**固定金利**\n\n| key | value | \n|:----------|:-----------|\n| 基準金利 | -- |\n| スプレッド | 4% |\n\n以下が完成形のコードです\n\n```swap_trade.sol\ncontract SwapTrade{\n    address public fixed_side;\n    address public floated_side;\n    uint public capital;\n    uint public fixed_rate;\n    uint public spread;\n    function SwapTrade(\n      address _fixed_side,\n      address _floated_side,\n      uint _capital,\n      uint _fixed_rate,\n      uint _spread\n      ){\n      fixed_side = _fixed_side;\n      floated_side = _floated_side;\n      capital = _capital;\n      fixed_rate = _fixed_rate;\n      spread = _spread;\n    }\n    function Execution(uint floating_rate){\n      floated_side.send(capital*fixed_rate);\n      fixed_side.send(capital*(floating_rate+spread));\n    }\n    function () {\n      throw;\n    }\n}\n```\n\n- SwapTrade：初期化\n- Execution：利息支払実行\n\n##コントラクト登録\n\nまずコードをコンパイルします。\n\n```\n> var source = \"contract SwapTrade{    address public fixed_side;    address public floated_side;    uint public capital;    uint public fixed_rate;    uint public spread;    function SwapTrade(      address _fixed_side,      address _floated_side,      uint _capital,      uint _fixed_rate,      uint _spread      ){      fixed_side = _fixed_side;      floated_side = _floated_side;      capital = _capital;      fixed_rate = _fixed_rate;      spread = _spread;    }    function Execution(uint floating_rate){      floated_side.send(capital*fixed_rate);      fixed_side.send(capital*(floating_rate+spread));    }    function () {      throw;    }}\"\n> var compiledSource = eth.compile.solidity(source)\n```\n\n続いて、コントラクトをEthereumのネットワークに送信します。\n\n```\n> var abiDefinition = compiledSource.SwapTrade.info.abiDefinition\n> var compiledContract = eth.contract(abiDefinition)\n> var fixedSide = \"0xc12b4d335ce5f0cf48001c8b06e1f941edb68e9d\"\n> var floatedSide = \"0xbc2ee815f7115c3d7cd1bc389fcb9b4f93c52830\"\n> var contract = compiledContract.new(fixedSide, floatedSide, 10*1.0e+18, 4, 2, {from: fixedSide, data: compiledSource.SwapTrade.code, gas:1000000, value: web3.toWei(100,\"ether\")})\n```\nここで、`fixedSide`は変動金利を支払うアドレス、`floatedSide`は固定金利を支払うアドレスです。\n`10*1.0e+18`,`4`,`2`はそれぞれ想定元本、固定金利、スプレッドを表しています。solidityでは浮動小数点は扱えないので、想定元本を1/100しています。(その後、単位をweiからetherに変更するため、10e+18倍しています。) 固定金利とスプレッドは100倍しています。\nまた `value: web3.toWei(100,\"ether\")` でfixedSideからこのアカウントに100etherデポジットしています。\n\n以下のようにコントラクトが送信されました。\n\n```\n> contract\n{\n  address: undefined,\n  transactionHash: \"0x3b0a5a32f549bec31bcf173274a344add2f319b9de0367071392e3fd9717ce07\"\n}\n> web3.fromWei(eth.getBalance(\"0x4934f96cbb5f82ead8d56f96ec11f98c826cc926\"),\"ether\")\n0\n> web3.fromWei(eth.getBalance(fixesSide),\"ether\")\n959.972328980000000030\n```\n\nこの状態ではコントラクトの残高は0です。\n\n続いてマイニングを行います。マイニングが完了すると以下のようになります。アドレスが付与されるているのがわかります。\n\n```\n> contract\n{\n  address: \"0x4934f96cbb5f82ead8d56f96ec11f98c826cc926\",\n  transactionHash: \"0x3b0a5a32f549bec31bcf173274a344add2f319b9de0367071392e3fd9717ce07\",\n  Execution: function(),\n  allEvents: function(),\n  capital: function(),\n  fixed_rate: function(),\n  fixed_side: function(),\n  floated_side: function(),\n  spread: function()\n}\n```\n\nまたコントラクトの残高がデポジット分変化しているのがわかります。\n\n```\n> web3.fromWei(eth.getBalance(\"0x4934f96cbb5f82ead8d56f96ec11f98c826cc926\"),\"ether\")\n100\n> web3.fromWei(eth.getBalance(fixesSide),\"ether\")\n859.96823490000000003\n```\n\n(本来であれば、この後floatedSideからも100etherデポジットする必要があるのですが、今回はその手続は省いて先に進みます。)\n\n##Executionメソッド\n初期化が完了しました。続いて1ヶ月がたった前提でExecutionメソッドを実行しましょう。\nこれは支払日に利息の支払いを実効するメソッドです。\n\n```\nfunction Execution(uint floating_rate){\n     floated_side.send(capital*fixed_rate);\n     fixed_side.send(capital*(floating_rate+spread));\n}\n```\n\nメソッドを呼び出しましょう。\n\n```\n> contract.Execution.sendTransaction(1, {from: fixedSide, gas:1000000})\n```\n\nマイニング前の両者のether残高です。\n\n```\n> web3.fromWei(eth.getBalance(fixedSide),\"ether\")\n859.96823490000000003\n> web3.fromWei(eth.getBalance(floatedSide),\"ether\")\n1439.96000000000000004\n```\n\nマイニング完了後は以下のように残高が変化します。利息分だけ両者の残高が増えているのがわかります。\n\nfixedSideは変動金利を受け取るので30ether増えます。\n変動金利：1000×(0.01+0.02) = 30\n\nfloatedSideは固定金利を受け取るので40ether増えます。\n固定金利：1000×0.04 = 40\n\n```\n> web3.fromWei(eth.getBalance(fixedSide),\"ether\")\n889.96752358000000003\n> web3.fromWei(eth.getBalance(floatedSide),\"ether\")\n1479.96000000000000004\n```\n実際に増えていますね。\n\n##まとめ\n今回まで3回に渡りSolidityを用いたコントラクトの開発方法について綴ってきました。\nこれを機に皆様がEthereumに興味を持ってくだされば幸いです。また何かあればいつでもご質問・ご連絡ください。\n","coediting":false,"created_at":"2016-05-19T00:26:40+09:00","id":"34292345ce303eb98166","private":false,"tags":[{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"Solidityによるコントラクトの作成(3) - スワップ取引","updated_at":"2016-05-19T00:26:40+09:00","url":"http://qiita.com/toshikase/items/34292345ce303eb98166","user":{"description":"","facebook_id":"","followees_count":14,"followers_count":7,"github_login_name":"toshikase","id":"toshikase","items_count":10,"linkedin_id":"","location":"Tokyo Japan","name":"","organization":"Sendee Inc.","permanent_id":61031,"profile_image_url":"https://avatars.githubusercontent.com/u/6286361?v=3","twitter_screen_name":null,"website_url":""}},{"rendered_body":"<p>前回の続きです。<br>\n前回 -&gt; <a href=\"http://qiita.com/Y-Mukoyama/items/5d751dc01ea4a45dc850\" id=\"reference-41f9c9aaf11b9ff3f658\">Boilerplateを使ったDapps(分散型アプリケーション)の作成(1)</a></p>\n\n<h2>\n<span id=\"ブロックチェーンをコントロールする\" class=\"fragment\"></span><a href=\"#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%E3%82%92%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>ブロックチェーンをコントロールする</h2>\n\n<p>前回の作業ですでにEthereumのAPIであるgethにコマンドを送ることで、Ethereumが起動した状態になっています。<br><br>\nその状態でマイニングをスタートしてみます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; miner.start()\ntrue\n</pre></div></div>\n\n<p>マイニングが行われているかどうかは下記コマンドで確認できます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; miner.hashrate\n500450 //ゼロじゃなかったらマイニングされている状態\n</pre></div></div>\n\n<p>ストップは下記です。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; miner.stop()\ntrue\n</pre></div></div>\n\n<p>今回はマイニングをしたまま開発を進めていきます。</p>\n\n<h2>\n<span id=\"アプリケーションの全体像\" class=\"fragment\"></span><a href=\"#%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%85%A8%E4%BD%93%E5%83%8F\"><i class=\"fa fa-link\"></i></a>アプリケーションの全体像</h2>\n\n<p>フォルダ構成は(抜粋すると)下記のようになっているかと思います。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n├── client\n│   ├── collections.js\n│   ├── index.js\n│   ├── lib\n│   │   ├── compatibility\n│   │   │   └── bootstrap.js\n│   │   ├── contracts\n│   │   │   └── MultiplyContract.sol\n│   │   ├── helpers\n│   │   │   ├── helperFunctions.js\n│   │   │   └── templateHelpers.js\n│   │   └── thirdparty\n│   │       ├── chance.min.js\n│   │       └── web3\n│   │           └── web3.js\n│   ├── meta.js\n│   ├── routes.js\n│   ├── stylesheets\n│   └── templates\n│       ├── components\n│       │   ├── accounts.html\n│       │   ├── accounts.js\n│       │   ├── balance.html\n│       │   ├── balance.js\n│       │   ├── multiplyContract.html\n│       │   ├── multiplyContract.js\n│       │   ├── networkHealth.html\n│       │   └── networkHealth.js\n│       ├── index.html\n│       ├── layout\n│       │   ├── _footer.html\n│       │   ├── _header.html\n│       │   ├── main.html\n│       │   └── notFound.html\n│       └── views\n│           ├── view1.html\n│           ├── view1.js\n│           ├── view2.html\n│           └── view2.js\n├── i18n\n├── project-tap.i18n\n├── public\n│   ├── fonts\n│   └── images\n├── settings.json\n├── test-genesis.json\n└── tests\n    └── mocha\n        └── client\n            └── MultiplyContract.js\n</pre></div></div>\n\n<p>Meteorでよく見かけるのは、ServerとClientにディレクトリを分けて、それぞれのサイドにおける開発を進めていく形でしょうか。<br><br>\n今回は、serverフォルダは存在せずに、Client側からだけで(実質的には)開発が可能なのMeteorの特徴が現れてています。</p>\n\n<p>その他、簡単にピックアップして説明すると、<br>\n- Meteorのデファクトスタンダードなルーティング用ライブラリ「iron-router」でルーティングが行われている<br>\n- Viewは、 <code>layout/main.html</code> から <code>views/view1 or views/view2</code> を呼び出し<br>\n- <code>views/view1 or views/view2</code> から <code>components/</code> 以下の各テンプレートファイルを呼び出し<br>\n- Componentsフォルダの各htmlファイル名に対応してJSファイルが作成される<br>\n- (基本的には)JSファイル内に、各Viewで呼び出すためのhelperやイベントを記載していく</p>\n\n<p>上記は主にMeteorの知識ですが、今回の特徴は、 <strong>Smart Contract</strong> を記載しているアプリであることです。<br><br>\nSmartContractは、デフォルトでは、 <code>client/lib/contracts</code> 以下に記載されています。<br><br>\nMeteorは独特の読み込みルールがあるため、それを意識した書き方が必要になります。<br>\n(参考:<a href=\"http://qiita.com/n-oshiro/items/be9be5639e09e2b80902\" id=\"reference-f54488b9cbf3602694b7\">Meteor 開発者がおさえておきたい「ファイルの読み込み順番(File Load Order)」<br>\n</a>)</p>\n\n<h2>\n<span id=\"smartcontractの中身\" class=\"fragment\"></span><a href=\"#smartcontract%E3%81%AE%E4%B8%AD%E8%BA%AB\"><i class=\"fa fa-link\"></i></a>SmartContractの中身</h2>\n\n<ul>\n<li>\n<code>.sol</code> という拡張子で保存されています。<br>\n</li>\n<li>Congractは「Solidity」という専用の言語で記載されています。</li>\n</ul>\n\n<p><code>client/lib/contracts/multiplyContract.sol</code> の中身は下記の通りです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\ncontract MultiplyContract {\n    function multiply(uint a) returns(uint d) {\n        return a * 7;\n    }\n}\n</pre></div></div>\n\n<p>上記のコードは、見たままではありますが、</p>\n\n<ul>\n<li>MultiplyContract という契約を宣言</li>\n<li>変数aと戻り値bを宣言して、引数を7倍したuint(符号なし整数)を戻す</li>\n</ul>\n\n<p>ということを記述しています。</p>\n\n<p>JSベースの言語で、チューリング完全を謳っており、どんな複雑な契約でもプログラミングにおとしこめるものであれば理論上は実現できます(ということになっています)。</p>\n\n<h2>\n<span id=\"smartcontractの動作確認\" class=\"fragment\"></span><a href=\"#smartcontract%E3%81%AE%E5%8B%95%E4%BD%9C%E7%A2%BA%E8%AA%8D\"><i class=\"fa fa-link\"></i></a>SmartContractの動作確認</h2>\n\n<p>Cloneしたままの状態で、Meteorを起動すると、View2へのリンクがあるはずです。<br><br>\nView2を開くとこのような画面が出るはずです。</p>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/3144eea7-131a-d8f7-50d6-9848dfd60641.png\" target=\"_blank\"><img src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/3144eea7-131a-d8f7-50d6-9848dfd60641.png\" alt=\"Screen Shot 2016-05-16 at 17.55.18.png\" title=\"Screen Shot 2016-05-16 at 17.55.18.png\"></a></p>\n\n<p>この画面に対応するhtmlとjsファイルは、 <code>multiplyContract.html</code> と <code>multiplyContact.js</code> です。</p>\n\n<p>下記は、multiplyContract.jsの抜粋です。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nTemplate['components_multiplyContract'].events({\n\n    /**\n    On \"Create New Contract\" click\n\n    @event (click .btn-default)\n    */\n\n    \"click .btn-default\": function(event, template){ // Create Contract\n        TemplateVar.set('state', {isMining: true});\n\n        // Set coinbase as the default account\n        web3.eth.defaultAccount = web3.eth.coinbase;\n\n        // assemble the tx object w/ default gas value\n        var transactionObject = {\n            data: MultiplyContract.bytecode, \n            gasPrice: web3.eth.gasPrice,\n            gas: 500000,\n            from: web3.eth.accounts[0]\n        };\n\n        // estimate gas cost then transact new MultiplyContract\n        web3.eth.estimateGas(transactionObject, function(err, estimateGas){\n            // multiply by 10 hack for testing\n            if(!err)\n                transactionObject.gas = estimateGas * 10;\n\n            MultiplyContract.new(transactionObject, \n                                 function(err, contract){\n                if(err)\n                    return TemplateVar.set(template, 'state', {isError: true, error: String(err)});\n\n                if(contract.address) {\n                    TemplateVar.set(template, 'state', {isMined: true, address: contract.address, source: source});\n                    contractInstance = contract;\n                }\n            });\n        });\n    },\n\n\n    /**\n    On Multiply Number Input keyup\n\n    @event (keyup #multiplyValue)\n    */\n\n    \"keyup #multiplyValue\": function(event, template){\n        // the input value\n        var value = template.find(\"#multiplyValue\").value;  \n\n        // call MultiplyContract method `multiply` which should multiply the `value` by 7\n        contractInstance.multiply.call(value, function(err, result){\n            TemplateVar.set(template, 'multiplyResult'\n                            , result.toNumber(10));\n\n            if(err)\n                TemplateVar.set(template, 'multplyResult'\n                                , String(err));\n        });\n    },\n});\n</pre></div></div>\n\n<p>こちらも簡単にですが説明すると、<br>\n- <code>.btn-default</code> がクリックされた際にイベントを発生させる<br>\n- Web3というJavaScript APIを用いて、ブロックチェーンにアクセスしたり色んなアクションを発生させたりする<br>\n- Web3についてはこちら(<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API\">JavaScript API</a>)<br>\n- <code>.sol</code> で記載したコントラクトを <code>MultiplyContract</code> クラスのように扱うことができる<br>\n- コントラクトが実行されるには、(testnetで)マイニングがされていることと、適切に取引時のgasを設定することが必要</p>\n\n<p>あとは通常のJSが扱えれば理解は出来るかと思います</p>\n\n<h2>\n<span id=\"動作後の画面\" class=\"fragment\"></span><a href=\"#%E5%8B%95%E4%BD%9C%E5%BE%8C%E3%81%AE%E7%94%BB%E9%9D%A2\"><i class=\"fa fa-link\"></i></a>動作後の画面</h2>\n\n<p>実際にボタンを押してみると下記のように取引実行後の画面が表示されます</p>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/7c1b9cbf-279c-c02b-e033-ca24d6147930.png\" target=\"_blank\"><img src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/7c1b9cbf-279c-c02b-e033-ca24d6147930.png\" alt=\"Screen Shot 2016-05-16 at 18.31.55.png\" title=\"Screen Shot 2016-05-16 at 18.31.55.png\"></a></p>\n\n<p>Contractがブロックチェーン上に流された結果、Contractのaddressが生成され、実行できるようになりました。</p>\n\n<p>「Type a value here to multiply」に数字を入力すると、(実際にはクライアント側での動作ですが)記載した契約通りに7倍された数字が戻ってくるのが分かるかと思います。</p>\n\n<p><br><br>\n今回もデフォルトのBoilerplateの説明に終始してしましましたが、次回は最後に、ContractやViewをカスタマイズして独自のDappを作成してみたいと思います。</p>\n\n<p><a href=\"http://qiita.com/Y-Mukoyama/items/36586d4b2a7e550bf2e1\" id=\"reference-28b81ff53c7cd5312292\">Boilerplateを使ったDapps(分散型アプリケーション)の作成(3)</a></p>\n","body":"\n前回の続きです。\n前回 -> [Boilerplateを使ったDapps(分散型アプリケーション)の作成(1)](http://qiita.com/Y-Mukoyama/items/5d751dc01ea4a45dc850)\n\n## ブロックチェーンをコントロールする\n前回の作業ですでにEthereumのAPIであるgethにコマンドを送ることで、Ethereumが起動した状態になっています。  \nその状態でマイニングをスタートしてみます。\n\n```\n> miner.start()\ntrue\n```\n\nマイニングが行われているかどうかは下記コマンドで確認できます。\n\n```\n> miner.hashrate\n500450 //ゼロじゃなかったらマイニングされている状態\n```\n\nストップは下記です。\n\n```\n> miner.stop()\ntrue\n```\n\n今回はマイニングをしたまま開発を進めていきます。\n\n\n## アプリケーションの全体像\nフォルダ構成は(抜粋すると)下記のようになっているかと思います。\n\n```\n├── client\n│   ├── collections.js\n│   ├── index.js\n│   ├── lib\n│   │   ├── compatibility\n│   │   │   └── bootstrap.js\n│   │   ├── contracts\n│   │   │   └── MultiplyContract.sol\n│   │   ├── helpers\n│   │   │   ├── helperFunctions.js\n│   │   │   └── templateHelpers.js\n│   │   └── thirdparty\n│   │       ├── chance.min.js\n│   │       └── web3\n│   │           └── web3.js\n│   ├── meta.js\n│   ├── routes.js\n│   ├── stylesheets\n│   └── templates\n│       ├── components\n│       │   ├── accounts.html\n│       │   ├── accounts.js\n│       │   ├── balance.html\n│       │   ├── balance.js\n│       │   ├── multiplyContract.html\n│       │   ├── multiplyContract.js\n│       │   ├── networkHealth.html\n│       │   └── networkHealth.js\n│       ├── index.html\n│       ├── layout\n│       │   ├── _footer.html\n│       │   ├── _header.html\n│       │   ├── main.html\n│       │   └── notFound.html\n│       └── views\n│           ├── view1.html\n│           ├── view1.js\n│           ├── view2.html\n│           └── view2.js\n├── i18n\n├── project-tap.i18n\n├── public\n│   ├── fonts\n│   └── images\n├── settings.json\n├── test-genesis.json\n└── tests\n    └── mocha\n        └── client\n            └── MultiplyContract.js\n```\n\nMeteorでよく見かけるのは、ServerとClientにディレクトリを分けて、それぞれのサイドにおける開発を進めていく形でしょうか。  \n今回は、serverフォルダは存在せずに、Client側からだけで(実質的には)開発が可能なのMeteorの特徴が現れてています。\n\nその他、簡単にピックアップして説明すると、\n- Meteorのデファクトスタンダードなルーティング用ライブラリ「iron-router」でルーティングが行われている\n- Viewは、 `layout/main.html` から `views/view1 or views/view2` を呼び出し\n- `views/view1 or views/view2` から `components/` 以下の各テンプレートファイルを呼び出し\n- Componentsフォルダの各htmlファイル名に対応してJSファイルが作成される\n- (基本的には)JSファイル内に、各Viewで呼び出すためのhelperやイベントを記載していく\n\n上記は主にMeteorの知識ですが、今回の特徴は、 **Smart Contract** を記載しているアプリであることです。  \nSmartContractは、デフォルトでは、 `client/lib/contracts` 以下に記載されています。  \nMeteorは独特の読み込みルールがあるため、それを意識した書き方が必要になります。\n(参考:[Meteor 開発者がおさえておきたい「ファイルの読み込み順番(File Load Order)」\n](http://qiita.com/n-oshiro/items/be9be5639e09e2b80902))\n\n## SmartContractの中身\n- `.sol` という拡張子で保存されています。  \n- Congractは「Solidity」という専用の言語で記載されています。\n\n`client/lib/contracts/multiplyContract.sol` の中身は下記の通りです。\n\n```\ncontract MultiplyContract {\n    function multiply(uint a) returns(uint d) {\n        return a * 7;\n    }\n}\n```\n\n上記のコードは、見たままではありますが、\n\n- MultiplyContract という契約を宣言\n- 変数aと戻り値bを宣言して、引数を7倍したuint(符号なし整数)を戻す\n\nということを記述しています。\n\nJSベースの言語で、チューリング完全を謳っており、どんな複雑な契約でもプログラミングにおとしこめるものであれば理論上は実現できます(ということになっています)。\n\n\n## SmartContractの動作確認\nCloneしたままの状態で、Meteorを起動すると、View2へのリンクがあるはずです。  \nView2を開くとこのような画面が出るはずです。\n\n![Screen Shot 2016-05-16 at 17.55.18.png](https://qiita-image-store.s3.amazonaws.com/0/87650/3144eea7-131a-d8f7-50d6-9848dfd60641.png \"Screen Shot 2016-05-16 at 17.55.18.png\")\n\n\nこの画面に対応するhtmlとjsファイルは、 `multiplyContract.html` と `multiplyContact.js` です。\n\n下記は、multiplyContract.jsの抜粋です。\n\n```\nTemplate['components_multiplyContract'].events({\n\n\t/**\n\tOn \"Create New Contract\" click\n\t\n\t@event (click .btn-default)\n\t*/\n\n\t\"click .btn-default\": function(event, template){ // Create Contract\n        TemplateVar.set('state', {isMining: true});\n        \n        // Set coinbase as the default account\n        web3.eth.defaultAccount = web3.eth.coinbase;\n        \n        // assemble the tx object w/ default gas value\n        var transactionObject = {\n            data: MultiplyContract.bytecode, \n            gasPrice: web3.eth.gasPrice,\n            gas: 500000,\n            from: web3.eth.accounts[0]\n        };\n        \n        // estimate gas cost then transact new MultiplyContract\n        web3.eth.estimateGas(transactionObject, function(err, estimateGas){\n            // multiply by 10 hack for testing\n            if(!err)\n                transactionObject.gas = estimateGas * 10;\n            \n            MultiplyContract.new(transactionObject, \n                                 function(err, contract){\n                if(err)\n                    return TemplateVar.set(template, 'state', {isError: true, error: String(err)});\n                \n                if(contract.address) {\n                    TemplateVar.set(template, 'state', {isMined: true, address: contract.address, source: source});\n                    contractInstance = contract;\n                }\n            });\n        });\n\t},\n\n    \n\t/**\n\tOn Multiply Number Input keyup\n\t\n\t@event (keyup #multiplyValue)\n\t*/\n\n\t\"keyup #multiplyValue\": function(event, template){\n        // the input value\n\t\tvar value = template.find(\"#multiplyValue\").value;  \n        \n        // call MultiplyContract method `multiply` which should multiply the `value` by 7\n\t\tcontractInstance.multiply.call(value, function(err, result){\n            TemplateVar.set(template, 'multiplyResult'\n                            , result.toNumber(10));\n            \n            if(err)\n                TemplateVar.set(template, 'multplyResult'\n                                , String(err));\n        });\n\t},\n});\n```\n\nこちらも簡単にですが説明すると、\n- `.btn-default` がクリックされた際にイベントを発生させる\n- Web3というJavaScript APIを用いて、ブロックチェーンにアクセスしたり色んなアクションを発生させたりする\n- Web3についてはこちら([JavaScript API](https://github.com/ethereum/wiki/wiki/JavaScript-API))\n- `.sol` で記載したコントラクトを `MultiplyContract` クラスのように扱うことができる\n- コントラクトが実行されるには、(testnetで)マイニングがされていることと、適切に取引時のgasを設定することが必要\n\n\nあとは通常のJSが扱えれば理解は出来るかと思います\n\n## 動作後の画面\n実際にボタンを押してみると下記のように取引実行後の画面が表示されます\n\n![Screen Shot 2016-05-16 at 18.31.55.png](https://qiita-image-store.s3.amazonaws.com/0/87650/7c1b9cbf-279c-c02b-e033-ca24d6147930.png \"Screen Shot 2016-05-16 at 18.31.55.png\")\n\nContractがブロックチェーン上に流された結果、Contractのaddressが生成され、実行できるようになりました。\n\n「Type a value here to multiply」に数字を入力すると、(実際にはクライアント側での動作ですが)記載した契約通りに7倍された数字が戻ってくるのが分かるかと思います。\n\n<br>\n今回もデフォルトのBoilerplateの説明に終始してしましましたが、次回は最後に、ContractやViewをカスタマイズして独自のDappを作成してみたいと思います。\n\n[Boilerplateを使ったDapps(分散型アプリケーション)の作成(3)](http://qiita.com/Y-Mukoyama/items/36586d4b2a7e550bf2e1)\n","coediting":false,"created_at":"2016-05-16T18:39:44+09:00","id":"0b0f094683805099213d","private":false,"tags":[{"name":"Meteor","versions":[]},{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"Boilerplateを使ったDapps(分散型アプリケーション)の作成(2)","updated_at":"2016-05-25T18:33:23+09:00","url":"http://qiita.com/Y-Mukoyama/items/0b0f094683805099213d","user":{"description":"","facebook_id":"yusuke.mukoyama.3","followees_count":2,"followers_count":2,"github_login_name":"YusukeMukoyama","id":"Y-Mukoyama","items_count":19,"linkedin_id":"","location":"Tokyo","name":"Yusuke Mukoyama","organization":"","permanent_id":87650,"profile_image_url":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/87650/721f6204557100b8cccc56e4e67a36f85f3eacf5/medium.png?1450101576","twitter_screen_name":"mukoyam","website_url":""}},{"rendered_body":"<p><a href=\"http://qiita.com/toshikase/items/28725215f7ad678b4b68\" id=\"reference-5fdfc2af44ad4424545a\">前回</a>はSolidityの使い方についてご説明しました。今回はSolidityを用いてオプション取引を実装してみましょう。</p>\n\n<h2>\n<span id=\"コントラクト概要\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E6%A6%82%E8%A6%81\"><i class=\"fa fa-link\"></i></a>コントラクト概要</h2>\n\n<p>今回はコール・オプションを実装します。コール・オプションとはある資産を買う権利のことです。(ちなみにある資産を売る権利をプット・オプションといいます)。</p>\n\n<p>コール・オプションのカラムは以下のようにします。</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left\">key</th>\n<th style=\"text-align: left\">value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left\">資産</td>\n<td style=\"text-align: left\">ビットコイン</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">数量</td>\n<td style=\"text-align: left\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">権利行使価格</td>\n<td style=\"text-align: left\">¥50,000</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">プレミアム</td>\n<td style=\"text-align: left\">¥5,000</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">期日</td>\n<td style=\"text-align: left\">1463127335</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">売り手</td>\n<td style=\"text-align: left\">0xfffe72483eb0bc804295af2416d2aeb4fa15a8bc</td>\n</tr>\n<tr>\n<td style=\"text-align: left\">買い手</td>\n<td style=\"text-align: left\">0x0e7b3774402f2f19a05e7a279238a4a1fe5e2bc0</td>\n</tr>\n</tbody>\n</table>\n\n<p>※<strong>1463127335</strong>は<strong>2016/05/13 8:15am(UTC)</strong>の<a href=\"http://www.unixtimestamp.com/\">UNIX TimeStamp</a>です</p>\n\n<p>以下が完成形のコードです</p>\n\n<div class=\"code-frame\" data-lang=\"text\">\n<div class=\"code-lang\"><span class=\"bold\">call_option.sol</span></div>\n<div class=\"highlight\"><pre>\ncontract CallOption{\n    address public buyer;\n    address public seller;\n    uint public btc_amount;\n    uint public btc_price;\n    uint public premium;\n    uint public exercise_date;\n    mapping (address =&gt; uint) public balanceOfJPY;\n    mapping (address =&gt; uint) public balanceOfBTC;\n    function CallOption(\n      address _seller,\n      uint _seller_jpy,\n      uint _seller_btc,\n      uint _btc_price,\n      uint _btc_amount,\n      uint _premium,\n      uint _exercise_date\n      ){\n      seller = _seller;\n      balanceOfJPY[seller] = _seller_jpy;\n      balanceOfBTC[seller] = _seller_btc;\n      btc_price = _btc_price;\n      btc_amount = _btc_amount;\n      premium = _premium;\n      exercise_date = _exercise_date;\n    }\n    function Respond (address _buyer, uint _buyer_jpy) {\n      buyer = _buyer;\n      balanceOfJPY[buyer] = _buyer_jpy;\n      if (balanceOfJPY[buyer] &lt; premium + btc_amount * btc_price) throw;\n      balanceOfJPY[buyer] -= premium;\n      balanceOfJPY[seller] += premium;\n    }\n    function Expire (uint _current_btc_price, uint _current_time){\n      if (_current_time &lt; exercise_date) throw;\n      if (_current_btc_price &lt; btc_price) throw;\n      balanceOfJPY[buyer] -= btc_price * btc_amount;\n      balanceOfJPY[seller] += btc_price * btc_amount;\n      balanceOfBTC[buyer] += btc_amount;\n      balanceOfBTC[seller] -= btc_amount;\n    }\n    function () {\n      throw;\n    }\n}\n</pre></div>\n</div>\n\n<ul>\n<li>CallOption：初期化(今回は、オプションの発行主体は常に売り手とします。)</li>\n<li>Respond：買い手の登録</li>\n<li>Expire：オプション実行</li>\n</ul>\n\n<h2>\n<span id=\"コントラクト登録\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E7%99%BB%E9%8C%B2\"><i class=\"fa fa-link\"></i></a>コントラクト登録</h2>\n\n<p>まずコードをコンパイルします。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; var source = \"contract CallOption{    address public buyer;    address public seller;    uint public btc_amount;    uint public btc_price;    uint public premium;    uint public exercise_date;    mapping (address =&gt; uint) public balanceOfJPY;    mapping (address =&gt; uint) public balanceOfBTC;    function CallOption(      address _seller,      uint _seller_jpy,      uint _seller_btc,      uint _btc_price,      uint _btc_amount,      uint _premium,      uint _exercise_date      ){      seller = _seller;      balanceOfJPY[seller] = _seller_jpy;      balanceOfBTC[seller] = _seller_btc;      btc_price = _btc_price;      btc_amount = _btc_amount;      premium = _premium;      exercise_date = _exercise_date;    }    function Respond (address _buyer, uint _buyer_jpy) {      buyer = _buyer;      balanceOfJPY[buyer] = _buyer_jpy;      if (balanceOfJPY[buyer] &lt; premium + btc_amount * btc_price) throw;      balanceOfJPY[buyer] -= premium;      balanceOfJPY[seller] += premium;    }    function Expire (uint _current_btc_price, uint _current_time){      if (_current_time &lt; exercise_date) throw;      if (_current_btc_price &lt; btc_price) throw;      balanceOfJPY[buyer] -= btc_price * btc_amount;      balanceOfJPY[seller] += btc_price * btc_amount;      balanceOfBTC[buyer] += btc_amount;      balanceOfBTC[seller] -= btc_amount;    }    function () {      throw;    }}\"\n&gt; var compiledSource = eth.compile.solidity(source)\n</pre></div></div>\n\n<p>続いて、コントラクトをEthereumのネットワークに送信します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; var abiDefinition = compiledSource.CallOption.info.abiDefinition\n&gt; var compiledContract = eth.contract(abiDefinition)\n&gt; var seller = \"0xfffe72483eb0bc804295af2416d2aeb4fa15a8bc\"\n&gt; var buyer = \"0x0e7b3774402f2f19a05e7a279238a4a1fe5e2bc0\"\n&gt; var contract = compiledContract.new(seller, 100000, 1,  50000, 1, 1463127335, {from: seller, data: compiledSource.CallOption.code, gas:1000000})\n</pre></div></div>\n\n<p>以下のようにコントラクトが送信されました。<br>\nしかしまだマイニングされていないので、アドレスは割り当てられていません。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract\n{\n  address: undefined,\n  transactionHash: \"0xf194ae6298b85b7fa6b0a9b75d115181ffb44ef546e4da9bcd970b943b01fa02\"\n}\n</pre></div></div>\n\n<p>マイニングが完了すると以下のようになります。アドレスが付与されるているのがわかります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract\n{\n  address: \"0x0bc2c62ecc340e0a4606d087f2d9d9afe0ef16d6\",\n  transactionHash: \"0xf194ae6298b85b7fa6b0a9b75d115181ffb44ef546e4da9bcd970b943b01fa02\",\n  Expire: function(),\n  Respond: function(),\n  allEvents: function(),\n  balanceOfBTC: function(),\n  balanceOfJPY: function(),\n  btc_amount: function(),\n  btc_price: function(),\n  buyer: function(),\n  exercise_date: function(),\n  premium: function(),\n  seller: function()\n}\n\n</pre></div></div>\n\n<h2>\n<span id=\"respondメソッド\" class=\"fragment\"></span><a href=\"#respond%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89\"><i class=\"fa fa-link\"></i></a>Respondメソッド</h2>\n\n<p>初期化が完了しました。続いてRespondメソッドを実行しましょう。<br>\n以下がコードです。第一引数は買い手のアドレス、第二引数は買い手のJPY残高を表しています。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n function Respond (address _buyer, uint _buyer_jpy) {\n      buyer = _buyer;\n      balanceOfJPY[buyer] = _buyer_jpy;\n      if (balanceOfJPY[buyer] &lt; premium + btc_amount * btc_price) throw;\n      balanceOfJPY[buyer] -= premium;\n      balanceOfJPY[seller] += premium;\n }\n</pre></div></div>\n\n<p>以下の条件文は、もしも買い手のJPY残高が (ビットコインの購入費+プレミアム) より少ない場合は、このメソッドは無効にするものです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nif (balanceOfJPY[buyer] &lt; premium + btc_amount * btc_price) throw;\n</pre></div></div>\n\n<p>メソッドを呼び出しましょう。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.Respond.sendTransaction(buyer, 100000, {from: buyer, gas:1000000})\n</pre></div></div>\n\n<p>まだマイニングが完了していないので、売りてと買い手のJPY残高は変化していません。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.balanceOfJPY(seller)\n100000\n&gt; contract.balanceOfJPY(buyer)\n0\n</pre></div></div>\n\n<p>マイニング完了後は以下のように残高が変化します。プレミアム分だけ売り手の残高が増えているのがわかります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.balanceOfJPY(seller)\n105000\n&gt; contract.balanceOfJPY(buyer)\n95000\n</pre></div></div>\n\n<h2>\n<span id=\"expireメソッド呼び出し\" class=\"fragment\"></span><a href=\"#expire%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97\"><i class=\"fa fa-link\"></i></a>Expireメソッド呼び出し</h2>\n\n<p>最後にExpireメソッドを実行しましょう。これは期日を過ぎたら、契約内容に沿って取引を実効するメソッドです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n  function Expire (uint _current_btc_price, uint _current_time){\n      if (_current_time &lt; exercise_date) throw; \n      if (_current_btc_price &lt; btc_price) throw;\n      balanceOfJPY[buyer] -= btc_price * btc_amount;\n      balanceOfJPY[seller] += btc_price * btc_amount;\n      balanceOfBTC[buyer] += btc_amount;\n      balanceOfBTC[seller] -= btc_amount;\n    }\n</pre></div></div>\n\n<p>期日に達してない場合は無効とする条件文です。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nif (_current_time &lt; exercise_date) throw;\n</pre></div></div>\n\n<p>現在のBTC価格が、権利行使価格より安い場合は無効とする条件文です。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nif (_current_btc_price &lt; btc_price) throw;\n</pre></div></div>\n\n<p>メソッドを呼び出します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\ncontract.Expire.sendTransaction(55000, 1463127340, {from:seller, gas:1000000}\n</pre></div></div>\n\n<p>BTC価格は¥55000(&gt;¥50000)、現在時刻は1463127340(&gt;1463127335)であるため、契約は実行されるはずです。</p>\n\n<p>マイニング前</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.balanceOfBTC(seller)\n1\n&gt; contract.balanceOfBTC(buyer)\n0\n&gt; contract.balanceOfJPY(seller)\n105000\n&gt; contract.balanceOfJPY(buyer)\n95000\n\n</pre></div></div>\n\n<p>マイニング後</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.balanceOfBTC(seller)\n0\n&gt; contract.balanceOfBTC(buyer)\n1\n&gt; contract.balanceOfJPY(seller)\n155000\n&gt; contract.balanceOfJPY(buyer)\n45000\n</pre></div></div>\n\n<p>契約条件に沿って、売り手と買い手のJPY残高とBTC残高が変化しているのが確認出来ました。</p>\n\n<h2>\n<span id=\"まとめ\" class=\"fragment\"></span><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"><i class=\"fa fa-link\"></i></a>まとめ</h2>\n\n<p>今回はSolidityを用いたオプション取引の実装方法をご説明しました。次回はスワップ取引の実装方法をご紹介致します。</p>\n","body":"[前回](http://qiita.com/toshikase/items/28725215f7ad678b4b68)はSolidityの使い方についてご説明しました。今回はSolidityを用いてオプション取引を実装してみましょう。\n\n##コントラクト概要\n今回はコール・オプションを実装します。コール・オプションとはある資産を買う権利のことです。(ちなみにある資産を売る権利をプット・オプションといいます)。\n\nコール・オプションのカラムは以下のようにします。\n\n| key | value | \n|:----------|:-----------|\n| 資産 | ビットコイン |\n| 数量 | 1 | \n| 権利行使価格 | ¥50,000 |\n| プレミアム | ¥5,000 | \n| 期日 |  1463127335 |\n| 売り手 |  0xfffe72483eb0bc804295af2416d2aeb4fa15a8bc | \n| 買い手 | 0x0e7b3774402f2f19a05e7a279238a4a1fe5e2bc0 |  \n\n※**1463127335**は**2016/05/13 8:15am(UTC)**の[UNIX TimeStamp](http://www.unixtimestamp.com/)です\n\n以下が完成形のコードです\n\n```call_option.sol\ncontract CallOption{\n    address public buyer;\n    address public seller;\n    uint public btc_amount;\n    uint public btc_price;\n    uint public premium;\n    uint public exercise_date;\n    mapping (address => uint) public balanceOfJPY;\n    mapping (address => uint) public balanceOfBTC;\n    function CallOption(\n      address _seller,\n      uint _seller_jpy,\n      uint _seller_btc,\n      uint _btc_price,\n      uint _btc_amount,\n      uint _premium,\n      uint _exercise_date\n      ){\n      seller = _seller;\n      balanceOfJPY[seller] = _seller_jpy;\n      balanceOfBTC[seller] = _seller_btc;\n      btc_price = _btc_price;\n      btc_amount = _btc_amount;\n      premium = _premium;\n      exercise_date = _exercise_date;\n    }\n    function Respond (address _buyer, uint _buyer_jpy) {\n      buyer = _buyer;\n      balanceOfJPY[buyer] = _buyer_jpy;\n      if (balanceOfJPY[buyer] < premium + btc_amount * btc_price) throw;\n      balanceOfJPY[buyer] -= premium;\n      balanceOfJPY[seller] += premium;\n    }\n    function Expire (uint _current_btc_price, uint _current_time){\n      if (_current_time < exercise_date) throw;\n      if (_current_btc_price < btc_price) throw;\n      balanceOfJPY[buyer] -= btc_price * btc_amount;\n      balanceOfJPY[seller] += btc_price * btc_amount;\n      balanceOfBTC[buyer] += btc_amount;\n      balanceOfBTC[seller] -= btc_amount;\n    }\n    function () {\n      throw;\n    }\n}\n```\n\n- CallOption：初期化(今回は、オプションの発行主体は常に売り手とします。)\n- Respond：買い手の登録\n- Expire：オプション実行\n\n##コントラクト登録\n\nまずコードをコンパイルします。\n\n```\n> var source = \"contract CallOption{    address public buyer;    address public seller;    uint public btc_amount;    uint public btc_price;    uint public premium;    uint public exercise_date;    mapping (address => uint) public balanceOfJPY;    mapping (address => uint) public balanceOfBTC;    function CallOption(      address _seller,      uint _seller_jpy,      uint _seller_btc,      uint _btc_price,      uint _btc_amount,      uint _premium,      uint _exercise_date      ){      seller = _seller;      balanceOfJPY[seller] = _seller_jpy;      balanceOfBTC[seller] = _seller_btc;      btc_price = _btc_price;      btc_amount = _btc_amount;      premium = _premium;      exercise_date = _exercise_date;    }    function Respond (address _buyer, uint _buyer_jpy) {      buyer = _buyer;      balanceOfJPY[buyer] = _buyer_jpy;      if (balanceOfJPY[buyer] < premium + btc_amount * btc_price) throw;      balanceOfJPY[buyer] -= premium;      balanceOfJPY[seller] += premium;    }    function Expire (uint _current_btc_price, uint _current_time){      if (_current_time < exercise_date) throw;      if (_current_btc_price < btc_price) throw;      balanceOfJPY[buyer] -= btc_price * btc_amount;      balanceOfJPY[seller] += btc_price * btc_amount;      balanceOfBTC[buyer] += btc_amount;      balanceOfBTC[seller] -= btc_amount;    }    function () {      throw;    }}\"\n> var compiledSource = eth.compile.solidity(source)\n```\n\n続いて、コントラクトをEthereumのネットワークに送信します。\n\n```\n> var abiDefinition = compiledSource.CallOption.info.abiDefinition\n> var compiledContract = eth.contract(abiDefinition)\n> var seller = \"0xfffe72483eb0bc804295af2416d2aeb4fa15a8bc\"\n> var buyer = \"0x0e7b3774402f2f19a05e7a279238a4a1fe5e2bc0\"\n> var contract = compiledContract.new(seller, 100000, 1,  50000, 1, 1463127335, {from: seller, data: compiledSource.CallOption.code, gas:1000000})\n```\n\n以下のようにコントラクトが送信されました。\nしかしまだマイニングされていないので、アドレスは割り当てられていません。\n\n```\n> contract\n{\n  address: undefined,\n  transactionHash: \"0xf194ae6298b85b7fa6b0a9b75d115181ffb44ef546e4da9bcd970b943b01fa02\"\n}\n```\n\nマイニングが完了すると以下のようになります。アドレスが付与されるているのがわかります。\n\n```\n> contract\n{\n  address: \"0x0bc2c62ecc340e0a4606d087f2d9d9afe0ef16d6\",\n  transactionHash: \"0xf194ae6298b85b7fa6b0a9b75d115181ffb44ef546e4da9bcd970b943b01fa02\",\n  Expire: function(),\n  Respond: function(),\n  allEvents: function(),\n  balanceOfBTC: function(),\n  balanceOfJPY: function(),\n  btc_amount: function(),\n  btc_price: function(),\n  buyer: function(),\n  exercise_date: function(),\n  premium: function(),\n  seller: function()\n}\n\n```\n\n##Respondメソッド\n初期化が完了しました。続いてRespondメソッドを実行しましょう。\n以下がコードです。第一引数は買い手のアドレス、第二引数は買い手のJPY残高を表しています。\n\n```\n function Respond (address _buyer, uint _buyer_jpy) {\n      buyer = _buyer;\n      balanceOfJPY[buyer] = _buyer_jpy;\n      if (balanceOfJPY[buyer] < premium + btc_amount * btc_price) throw;\n      balanceOfJPY[buyer] -= premium;\n      balanceOfJPY[seller] += premium;\n }\n```\n\n以下の条件文は、もしも買い手のJPY残高が (ビットコインの購入費+プレミアム) より少ない場合は、このメソッドは無効にするものです。\n\n```\nif (balanceOfJPY[buyer] < premium + btc_amount * btc_price) throw;\n```\n\nメソッドを呼び出しましょう。\n\n```\n> contract.Respond.sendTransaction(buyer, 100000, {from: buyer, gas:1000000})\n```\n\nまだマイニングが完了していないので、売りてと買い手のJPY残高は変化していません。\n\n```\n> contract.balanceOfJPY(seller)\n100000\n> contract.balanceOfJPY(buyer)\n0\n```\n\nマイニング完了後は以下のように残高が変化します。プレミアム分だけ売り手の残高が増えているのがわかります。\n\n```\n> contract.balanceOfJPY(seller)\n105000\n> contract.balanceOfJPY(buyer)\n95000\n```\n\n##Expireメソッド呼び出し\n最後にExpireメソッドを実行しましょう。これは期日を過ぎたら、契約内容に沿って取引を実効するメソッドです。\n\n```\n  function Expire (uint _current_btc_price, uint _current_time){\n      if (_current_time < exercise_date) throw; \n      if (_current_btc_price < btc_price) throw;\n      balanceOfJPY[buyer] -= btc_price * btc_amount;\n      balanceOfJPY[seller] += btc_price * btc_amount;\n      balanceOfBTC[buyer] += btc_amount;\n      balanceOfBTC[seller] -= btc_amount;\n    }\n```\n\n期日に達してない場合は無効とする条件文です。\n\n```\nif (_current_time < exercise_date) throw;\n```\n\n現在のBTC価格が、権利行使価格より安い場合は無効とする条件文です。\n\n```\nif (_current_btc_price < btc_price) throw;\n```\n\nメソッドを呼び出します。\n\n```\ncontract.Expire.sendTransaction(55000, 1463127340, {from:seller, gas:1000000}\n```\n\nBTC価格は¥55000(>¥50000)、現在時刻は1463127340(>1463127335)であるため、契約は実行されるはずです。\n\nマイニング前\n\n```\n> contract.balanceOfBTC(seller)\n1\n> contract.balanceOfBTC(buyer)\n0\n> contract.balanceOfJPY(seller)\n105000\n> contract.balanceOfJPY(buyer)\n95000\n\n```\n\nマイニング後\n\n```\n> contract.balanceOfBTC(seller)\n0\n> contract.balanceOfBTC(buyer)\n1\n> contract.balanceOfJPY(seller)\n155000\n> contract.balanceOfJPY(buyer)\n45000\n```\n\n契約条件に沿って、売り手と買い手のJPY残高とBTC残高が変化しているのが確認出来ました。\n\n\n##まとめ\n今回はSolidityを用いたオプション取引の実装方法をご説明しました。次回はスワップ取引の実装方法をご紹介致します。\n\n","coediting":false,"created_at":"2016-05-13T19:35:30+09:00","id":"467f8998506a2f0cf258","private":false,"tags":[{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"Solidityによるコントラクトの作成(2) - オプション取引","updated_at":"2016-05-13T19:43:31+09:00","url":"http://qiita.com/toshikase/items/467f8998506a2f0cf258","user":{"description":"","facebook_id":"","followees_count":14,"followers_count":7,"github_login_name":"toshikase","id":"toshikase","items_count":10,"linkedin_id":"","location":"Tokyo Japan","name":"","organization":"Sendee Inc.","permanent_id":61031,"profile_image_url":"https://avatars.githubusercontent.com/u/6286361?v=3","twitter_screen_name":null,"website_url":""}},{"rendered_body":"<p>Ethereumを用いて、非中央集権・分散型アプリケーション、いわゆる <strong>「Dapps」</strong> を作成してみます。<br>\n今回は、Meteorで作られたBoilerplate(<a href=\"https://github.com/SilentCicero/meteor-dapp-boilerplate\">SilentCicero/meteor-dapp-boilerplate</a>)を用います。</p>\n\n<h2>\n<span id=\"到達目標\" class=\"fragment\"></span><a href=\"#%E5%88%B0%E9%81%94%E7%9B%AE%E6%A8%99\"><i class=\"fa fa-link\"></i></a>到達目標</h2>\n\n<p>テンプレートにあるContractを書き換えて、独自のテストネット上にトランザクションを流し、マイニングにより承認されるまでの、一通りの流れを実装する</p>\n\n<h2>\n<span id=\"meteorの簡単な紹介\" class=\"fragment\"></span><a href=\"#meteor%E3%81%AE%E7%B0%A1%E5%8D%98%E3%81%AA%E7%B4%B9%E4%BB%8B\"><i class=\"fa fa-link\"></i></a>Meteorの簡単な紹介</h2>\n\n<ul>\n<li>Ycombinater出身のチームが開発している、JavaScript(Node.js)で超速にアプリケーションを開発できるというクールなフレームワーク</li>\n<li>MongoDBが組み込まれている</li>\n<li>サーバー/クライアント間のデータ連携がシームレスに行われる(ちょっと感動するレベル)</li>\n<li>簡素で柔軟なMVC</li>\n<li>Blazeと呼ばれるテンプレートエンジンを採用</li>\n<li>リアクティブ・プログラミング</li>\n<li>公式 : <a href=\"https://www.meteor.com/\" class=\"autolink\">https://www.meteor.com/</a>\n</li>\n</ul>\n\n<h2>\n<span id=\"dappsとは\" class=\"fragment\"></span><a href=\"#dapps%E3%81%A8%E3%81%AF\"><i class=\"fa fa-link\"></i></a>Dappsとは</h2>\n\n<ul>\n<li>Decentralized Appsの略</li>\n<li>統一された明確な定義があるわけではないが、ざっくりとした表現だと「P2Pで中央機関が無く、プロトコルに従って自律的に運用されるWebアプリケーション」</li>\n</ul>\n\n<h2>\n<span id=\"その他にも前提となる知識\" class=\"fragment\"></span><a href=\"#%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AB%E3%82%82%E5%89%8D%E6%8F%90%E3%81%A8%E3%81%AA%E3%82%8B%E7%9F%A5%E8%AD%98\"><i class=\"fa fa-link\"></i></a>その他にも前提となる知識</h2>\n\n<ul>\n<li>Ethereum...<a href=\"https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%BC%E3%82%B5%E3%83%AA%E3%82%A2%E3%83%A0\">Wikipedia</a>\n</li>\n<li>SmartContract...いわゆる契約の「プログラミング化」(<a href=\"http://jpbitcoin.com/bitcoin2/smartcontract\">スマートコントラクトとDAO</a>)</li>\n<li>Solidity...Ethereum上で動作するJSベースのSmartContract記述用言語(<a href=\"https://solidity.readthedocs.io/en/latest/\">公式wiki</a>)</li>\n<li>geth...EthereumのGo言語クライアント(<a href=\"https://github.com/ethereum/go-ethereum/wiki\">公式wiki</a>)</li>\n</ul>\n\n<h2>\n<span id=\"開発環境\" class=\"fragment\"></span><a href=\"#%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83\"><i class=\"fa fa-link\"></i></a>開発環境</h2>\n\n<ul>\n<li>Mac OSX : 10.11.4</li>\n<li>geth, Node.js, Meteor等、必要なものは全てインストール済として進めていきます</li>\n</ul>\n\n<h2>\n<span id=\"gethをプライベートネットワークで起動する\" class=\"fragment\"></span><a href=\"#geth%E3%82%92%E3%83%97%E3%83%A9%E3%82%A4%E3%83%99%E3%83%BC%E3%83%88%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%A7%E8%B5%B7%E5%8B%95%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>gethをプライベートネットワークで起動する</h2>\n\n<p>まずはgethテストネットを起動します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n$ geth --networkid \"10\" --nodiscover --datadir \"~/testnet\" --genesis \"/~/testnet/test.json\" --unlock {アカウントNo} --rpc --rpcaddr \"localhost\" --rpcport \"8545\" --rpccorsdomain \"*\" console 2&gt;&gt; ~/testnet/test_err.log\n</pre></div></div>\n\n<p>コマンドラインオプションは <code>geth help</code> で参照可能です。<br><br>\n大事なポイントは、アカウントをunlockしておくこと、crosdomainのオプションをつけることくらいかと思います。</p>\n\n<p>※ 参考(<a href=\"https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options\" class=\"autolink\">https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options</a>)</p>\n\n<h2>\n<span id=\"templateをセットアップ\" class=\"fragment\"></span><a href=\"#template%E3%82%92%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97\"><i class=\"fa fa-link\"></i></a>templateをセットアップ</h2>\n\n<p>今回使わせていただくテンプレートをクローンしてきます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n$ git clone https://github.com/SilentCicero/meteor-dapp-boilerplate.git\n</pre></div></div>\n\n<p>必要十分なパッケージが既に入っているので、基本的にはライブラリとかはこのままでOK。<br>\n<a href=\"https://github.com/SilentCicero/meteor-dapp-boilerplate#-included-packages\">※Include Packagesのリスト</a><br><br>\nちなみにMeteorのライブラリは「<a href=\"https://atmospherejs.com/\">Atmosphere</a>」と呼ばれています。クールです。</p>\n\n<h2>\n<span id=\"立ち上げてみる\" class=\"fragment\"></span><a href=\"#%E7%AB%8B%E3%81%A1%E4%B8%8A%E3%81%92%E3%81%A6%E3%81%BF%E3%82%8B\"><i class=\"fa fa-link\"></i></a>立ち上げてみる</h2>\n\n<p>そして、まずはそのままMeteorを立ち上げてみます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n$ cd meteor-dapp-boilerplate/app\n$ meteor\n</pre></div></div>\n\n<p>これで自動的に必要なパッケージのインストールが始まりローカルホストでサーバーが立ち上がります。<br>\n上手くいけば下記画像のようになるはず。</p>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/87650/cf079a4d-aa2a-3ffa-7803-12af2ec042be.png\" target=\"_blank\"><img src=\"https://qiita-image-store.s3.amazonaws.com/0/87650/cf079a4d-aa2a-3ffa-7803-12af2ec042be.png\" alt=\"Screen Shot 2016-05-12 at 23.05.37.png\" title=\"Screen Shot 2016-05-12 at 23.05.37.png\"></a></p>\n\n<p>View1には、テストネットとの接続状況や、アカウントの情報、Ether残高などが記載されていると思います。<br><br>\nMiningされているかどうかも確認できます。</p>\n\n<p><br></p>\n\n<p>長くなったので、後半は第二回に続きます。</p>\n\n<p><a href=\"http://qiita.com/Y-Mukoyama/items/0b0f094683805099213d\" id=\"reference-aa4c319d45835b872892\">第2回</a></p>\n","body":"\nEthereumを用いて、非中央集権・分散型アプリケーション、いわゆる **「Dapps」** を作成してみます。\n今回は、Meteorで作られたBoilerplate([SilentCicero/meteor-dapp-boilerplate](https://github.com/SilentCicero/meteor-dapp-boilerplate))を用います。\n\n## 到達目標\nテンプレートにあるContractを書き換えて、独自のテストネット上にトランザクションを流し、マイニングにより承認されるまでの、一通りの流れを実装する\n\n## Meteorの簡単な紹介\n- Ycombinater出身のチームが開発している、JavaScript(Node.js)で超速にアプリケーションを開発できるというクールなフレームワーク\n- MongoDBが組み込まれている\n- サーバー/クライアント間のデータ連携がシームレスに行われる(ちょっと感動するレベル)\n- 簡素で柔軟なMVC\n- Blazeと呼ばれるテンプレートエンジンを採用\n- リアクティブ・プログラミング\n- 公式 : https://www.meteor.com/\n\n## Dappsとは\n- Decentralized Appsの略\n- 統一された明確な定義があるわけではないが、ざっくりとした表現だと「P2Pで中央機関が無く、プロトコルに従って自律的に運用されるWebアプリケーション」\n\n## その他にも前提となる知識\n- Ethereum...[Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%BC%E3%82%B5%E3%83%AA%E3%82%A2%E3%83%A0)\n- SmartContract...いわゆる契約の「プログラミング化」([スマートコントラクトとDAO](http://jpbitcoin.com/bitcoin2/smartcontract))\n- Solidity...Ethereum上で動作するJSベースのSmartContract記述用言語([公式wiki](https://solidity.readthedocs.io/en/latest/))\n- geth...EthereumのGo言語クライアント([公式wiki](https://github.com/ethereum/go-ethereum/wiki))\n\n## 開発環境\n- Mac OSX : 10.11.4\n- geth, Node.js, Meteor等、必要なものは全てインストール済として進めていきます\n\n## gethをプライベートネットワークで起動する\nまずはgethテストネットを起動します。\n\n```\n$ geth --networkid \"10\" --nodiscover --datadir \"~/testnet\" --genesis \"/~/testnet/test.json\" --unlock {アカウントNo} --rpc --rpcaddr \"localhost\" --rpcport \"8545\" --rpccorsdomain \"*\" console 2>> ~/testnet/test_err.log\n```\n\nコマンドラインオプションは `geth help` で参照可能です。  \n大事なポイントは、アカウントをunlockしておくこと、crosdomainのオプションをつけることくらいかと思います。\n\n※ 参考(https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options)\n\n## templateをセットアップ\n今回使わせていただくテンプレートをクローンしてきます。\n\n```\n$ git clone https://github.com/SilentCicero/meteor-dapp-boilerplate.git\n```\n\n必要十分なパッケージが既に入っているので、基本的にはライブラリとかはこのままでOK。\n[※Include Packagesのリスト](https://github.com/SilentCicero/meteor-dapp-boilerplate#-included-packages)  \nちなみにMeteorのライブラリは「[Atmosphere](https://atmospherejs.com/)」と呼ばれています。クールです。\n\n## 立ち上げてみる\nそして、まずはそのままMeteorを立ち上げてみます。\n\n```\n$ cd meteor-dapp-boilerplate/app\n$ meteor\n```\n\nこれで自動的に必要なパッケージのインストールが始まりローカルホストでサーバーが立ち上がります。\n上手くいけば下記画像のようになるはず。\n\n![Screen Shot 2016-05-12 at 23.05.37.png](https://qiita-image-store.s3.amazonaws.com/0/87650/cf079a4d-aa2a-3ffa-7803-12af2ec042be.png \"Screen Shot 2016-05-12 at 23.05.37.png\")\n\nView1には、テストネットとの接続状況や、アカウントの情報、Ether残高などが記載されていると思います。  \nMiningされているかどうかも確認できます。\n\n<br>\n\n長くなったので、後半は第二回に続きます。\n\n[第2回](http://qiita.com/Y-Mukoyama/items/0b0f094683805099213d)\n","coediting":false,"created_at":"2016-05-12T23:10:14+09:00","id":"5d751dc01ea4a45dc850","private":false,"tags":[{"name":"Meteor","versions":[]},{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"Boilerplateを使ったDapps(分散型アプリケーション)の作成(1)","updated_at":"2016-05-25T18:33:34+09:00","url":"http://qiita.com/Y-Mukoyama/items/5d751dc01ea4a45dc850","user":{"description":"","facebook_id":"yusuke.mukoyama.3","followees_count":2,"followers_count":2,"github_login_name":"YusukeMukoyama","id":"Y-Mukoyama","items_count":19,"linkedin_id":"","location":"Tokyo","name":"Yusuke Mukoyama","organization":"","permanent_id":87650,"profile_image_url":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/87650/721f6204557100b8cccc56e4e67a36f85f3eacf5/medium.png?1450101576","twitter_screen_name":"mukoyam","website_url":""}},{"rendered_body":"<p>今回はSolidityを用いたコントラクトの作り方について説明致します。</p>\n\n<p>開発環境<br>\nOS : OSX 10.11.4</p>\n\n<h2>\n<span id=\"ethereumインストール\" class=\"fragment\"></span><a href=\"#ethereum%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\"><i class=\"fa fa-link\"></i></a>Ethereumインストール</h2>\n\n<p>Ethereumをインストールしていない方は、インストールしてください。<br>\nConsoleで以下のコマンドを叩けばインストールされます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nbash &lt;(curl https://install-geth.ethereum.org -L)\n</pre></div></div>\n\n<p>その他のインストール方法については<a href=\"https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum\">こちら</a>を参考にしてください。</p>\n\n<h2>\n<span id=\"ethereum立ち上げ\" class=\"fragment\"></span><a href=\"#ethereum%E7%AB%8B%E3%81%A1%E4%B8%8A%E3%81%92\"><i class=\"fa fa-link\"></i></a>Ethereum立ち上げ</h2>\n\n<p>続いてEthereumをを立ち上げましょう。今回はテスト用に使うため、Private_netを立ち上げます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\ngeth --networkid \"11\"  --datadir \"path_to_directory\" --genesis \"path_to_genesisjson\" console\n</pre></div></div>\n\n<p><code>--networkid</code>：networkIDを指定します。1,2,3以外の数字を使いましょう。<br>\n<code>--genesis</code>　：genesis blockを指定します。<br>\n<code>--datadir</code>　：databaseのあるディレクトリを指定します。<br>\n<code>console</code>　　：consoleを開くために必要です。</p>\n\n<p><a href=\"https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options\">geth command line options</a></p>\n\n<h2>\n<span id=\"コントラクト作成\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E4%BD%9C%E6%88%90\"><i class=\"fa fa-link\"></i></a>コントラクト作成</h2>\n\n<p>早速コントラクトを記述してみましょう。言語はSolidityを使います。<br>\n(事前にsolidityコンパイラ(solc)がインストールされているか確認してください。されてない場合は<a href=\"http://book.ethereum-jp.net/first_use/contract.html\">こちらの記事</a>に沿ってインストールしてください。)</p>\n\n<p>エディタで次のようなコントラクトを記述しましょう。これはEthereum上に独自のコインを作るためのコントラクトです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\">\n<div class=\"code-lang\"><span class=\"bold\">token.sol</span></div>\n<div class=\"highlight\"><pre>\ncontract token { \n    mapping (address =&gt; uint) public coinBalanceOf;\n    event CoinTransfer(address sender, address receiver, uint amount);\n\n  /* Contract初期化のための関数。contract名と同じにする */\n  function token(uint supply) {\n        coinBalanceOf[msg.sender] = supply;\n    }\n\n  /* コインを送るための関数 */\n    function sendCoin(address receiver, uint amount) returns(bool sufficient) {\n        if (coinBalanceOf[msg.sender] &lt; amount) return false;\n        coinBalanceOf[msg.sender] -= amount;\n        coinBalanceOf[receiver] += amount;\n        CoinTransfer(msg.sender, receiver, amount);\n        return true;\n    }\n}\n</pre></div>\n</div>\n\n<p>このコントラクトから改行を削除します。テキストから改行を削除する方法については<a href=\"http://linux.just4fun.biz/%E9%80%86%E5%BC%95%E3%81%8DUNIX%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%8B%E3%82%89%E6%94%B9%E8%A1%8C%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B.html\">こちらの記事</a>を参考にしてください。</p>\n\n<div class=\"code-frame\" data-lang=\"text\">\n<div class=\"code-lang\"><span class=\"bold\">token_one_line.sol</span></div>\n<div class=\"highlight\"><pre>\ncontract token {    mapping (address =&gt; uint) public coinBalanceOf;    event CoinTransfer(address sender, address receiver, uint amount);  /* Contract初期化のための関数。contract名と同じにする */  function token(uint supply) {        coinBalanceOf[msg.sender] = supply;    }  /* コインを送るための関数 */    function sendCoin(address receiver, uint amount) returns(bool sufficient) {        if (coinBalanceOf[msg.sender] &lt; amount) return false;        coinBalanceOf[msg.sender] -= amount;        coinBalanceOf[receiver] += amount;        CoinTransfer(msg.sender, receiver, amount);        return true;    }}\n</pre></div>\n</div>\n\n<h3>\n<span id=\"コンパイル\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB\"><i class=\"fa fa-link\"></i></a>コンパイル</h3>\n\n<p>続いて、<code>solc</code>を用いてコントラクトをコンパイルします。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; var source = \"contract token {    mapping (address =&gt; uint) public coinBalanceOf;    event CoinTransfer(address sender, address receiver, uint amount);  /* Contract初期化のための関数。contract名と同じにする */  function token(uint supply) {        coinBalanceOf[msg.sender] = supply;    }  /* コインを送るための関数 */    function sendCoin(address receiver, uint amount) returns(bool sufficient) {        if (coinBalanceOf[msg.sender] &lt; amount) return false;        coinBalanceOf[msg.sender] -= amount;        coinBalanceOf[receiver] += amount;        CoinTransfer(msg.sender, receiver, amount);        return true;    }}\"\n&gt; var compiledSource = eth.compile.solidity(source)\n</pre></div></div>\n\n<p>これでコンパイルは完了しました。続いてコンパイルしたコードをEthereumのネットワークに送信します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; var abiDefinition = compiledSource.token.info.abiDefinition\n&gt; var compiledContract = eth.contract(abiDefinition)\n&gt; var supply = 10000\n&gt; var contract = compiledContract.new(supply, {from:eth.accounts[0], data: compiledSource.token.code, gas:1000000})\n</pre></div></div>\n\n<p>これでネットワークへの送信は完了しました。しかしまだマイニングは行われていないので、このコントラクトは承認されていません。そのためaddressもまだ未定です。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract\n{\n  address: undefined,\n  transactionHash: \"0x09b7b27e8d948b601ef1dd0548c7d33604c2fc7b8ee31d7d8e637f66da302a69\"\n}\n</pre></div></div>\n\n<p>マイニングが完了すると以下のようにaddressが付与されます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract\n{\n  address: \"0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\",\n  transactionHash: \"0x09b7b27e8d948b601ef1dd0548c7d33604c2fc7b8ee31d7d8e637f66da302a69\",\n  CoinTransfer: function(),\n  allEvents: function(),\n  coinBalanceOf: function(),\n  sendCoin: function()\n}\n</pre></div></div>\n\n<h3>\n<span id=\"コントラクトのメソッドを用いる\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%81%AE%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%92%E7%94%A8%E3%81%84%E3%82%8B\"><i class=\"fa fa-link\"></i></a>コントラクトのメソッドを用いる</h3>\n\n<p>コントラクトで定義されているメソッドを呼び出してみましょう。<br>\n以下のsendCoinメソッドは引数を2つとります。1つ目は受取主、2つ目は送金額です。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.sendCoin.sendTransaction(eth.accounts[1], 1000, {from: eth.accounts[0]})\nI0511 22:09:00.939817    8397 xeth.go:1028] Tx(0xcd1003befe323aa1cdaee4e81e032b07cfe70fffc33400f46d033dc86cf4c4a1) to: 0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\n\"0xcd1003befe323aa1cdaee4e81e032b07cfe70fffc33400f46d033dc86cf4c4a1\"\n</pre></div></div>\n\n<p>メソッドがネットワークに送信されました。しかしまだマイニングされていないので、eth.accounts[0]の残高は10,000、eth.accounts[1]の残高は0のままです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.coinBalanceOf(eth.accounts[0])\n10000\n&gt; contract.coinBalanceOf(eth.accounts[1])\n0\n</pre></div></div>\n\n<p>マイニングを行います。すると残高が以下のように変化します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.coinBalanceOf(eth.accounts[0])\n9000\n&gt; contract.coinBalanceOf(eth.accounts[1])\n1000\n</pre></div></div>\n\n<p>以上がコントラクト内のメソッドの呼び出し方です。</p>\n\n<h3>\n<span id=\"外部からコントラクトにアクセスする\" class=\"fragment\"></span><a href=\"#%E5%A4%96%E9%83%A8%E3%81%8B%E3%82%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>外部からコントラクトにアクセスする</h3>\n\n<p>第三者がコントラクトにアクセスするには<code>AbiDefinition</code>と<code>address</code>が必要です。今回の場合は以下になります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; abiDefinition \n[{\n    constant: false,\n    inputs: [{\n        name: \"receiver\",\n        type: \"address\"\n    }, {\n        name: \"amount\",\n        type: \"uint256\"\n    }],\n    name: \"sendCoin\",\n    outputs: [{\n        name: \"sufficient\",\n        type: \"bool\"\n    }],\n    type: \"function\"\n}, {\n    constant: true,\n    inputs: [{\n        name: \"\",\n        type: \"address\"\n    }],\n    name: \"coinBalanceOf\",\n    outputs: [{\n        name: \"\",\n        type: \"uint256\"\n    }],\n    type: \"function\"\n}, {\n    inputs: [{\n        name: \"supply\",\n        type: \"uint256\"\n    }],\n    type: \"constructor\"\n}, {\n    anonymous: false,\n    inputs: [{\n        indexed: false,\n        name: \"sender\",\n        type: \"address\"\n    }, {\n        indexed: false,\n        name: \"receiver\",\n        type: \"address\"\n    }, {\n        indexed: false,\n        name: \"amount\",\n        type: \"uint256\"\n    }],\n    name: \"CoinTransfer\",\n    type: \"event\"\n}]\n</pre></div></div>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract.address\n\"0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\"\n</pre></div></div>\n\n<p>上記のデータを用いて、コントラクトにアクセスする変数を作成します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; var theContract = eth.contract(abiDefinition).at(contract.address)\n&gt; theContract\n{\n  address: \"0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\",\n  CoinTransfer: function(),\n  allEvents: function(),\n  coinBalanceOf: function(),\n  sendCoin: function()\n}\n</pre></div></div>\n\n<p>これで第三者がコントラクトにアクセス出来るようになりました。</p>\n\n<h3>\n<span id=\"まとめ\" class=\"fragment\"></span><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"><i class=\"fa fa-link\"></i></a>まとめ</h3>\n\n<p>以上Solidityを使ったコントラクトの作成方法でした。次回はSolidityを用いたデリバティブの実装方法についてご説明致します。</p>\n\n<h3>\n<span id=\"参考記事\" class=\"fragment\"></span><a href=\"#%E5%8F%82%E8%80%83%E8%A8%98%E4%BA%8B\"><i class=\"fa fa-link\"></i></a>参考記事</h3>\n\n<p><a href=\"https://ethereum.gitbooks.io/frontier-guide/content/ether_transfer.html\" class=\"autolink\">https://ethereum.gitbooks.io/frontier-guide/content/ether_transfer.html</a><br>\n<a href=\"http://book.ethereum-jp.net/first_use/contract.html\" class=\"autolink\">http://book.ethereum-jp.net/first_use/contract.html</a><br>\n<a href=\"https://solidity.readthedocs.io/en/latest/index.html\" class=\"autolink\">https://solidity.readthedocs.io/en/latest/index.html</a><br>\n<a href=\"http://linux.just4fun.biz/%E9%80%86%E5%BC%95%E3%81%8DUNIX%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%8B%E3%82%89%E6%94%B9%E8%A1%8C%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B.html\" class=\"autolink\">http://linux.just4fun.biz/%E9%80%86%E5%BC%95%E3%81%8DUNIX%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%8B%E3%82%89%E6%94%B9%E8%A1%8C%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B.html</a></p>\n","body":"今回はSolidityを用いたコントラクトの作り方について説明致します。\n\n開発環境\nOS : OSX 10.11.4\n\n## Ethereumインストール\nEthereumをインストールしていない方は、インストールしてください。\nConsoleで以下のコマンドを叩けばインストールされます。\n\n````\nbash <(curl https://install-geth.ethereum.org -L)\n```\nその他のインストール方法については[こちら](https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum)を参考にしてください。\n\n## Ethereum立ち上げ\n続いてEthereumをを立ち上げましょう。今回はテスト用に使うため、Private_netを立ち上げます。\n\n```\ngeth --networkid \"11\"  --datadir \"path_to_directory\" --genesis \"path_to_genesisjson\" console\n```\n\n`--networkid`：networkIDを指定します。1,2,3以外の数字を使いましょう。\n`--genesis`　：genesis blockを指定します。\n`--datadir`　：databaseのあるディレクトリを指定します。\n`console`　　：consoleを開くために必要です。\n\n[geth command line options](https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options)\n\n## コントラクト作成\n早速コントラクトを記述してみましょう。言語はSolidityを使います。\n(事前にsolidityコンパイラ(solc)がインストールされているか確認してください。されてない場合は[こちらの記事](http://book.ethereum-jp.net/first_use/contract.html)に沿ってインストールしてください。)\n\nエディタで次のようなコントラクトを記述しましょう。これはEthereum上に独自のコインを作るためのコントラクトです。\n\n```token.sol\ncontract token { \n    mapping (address => uint) public coinBalanceOf;\n    event CoinTransfer(address sender, address receiver, uint amount);\n\n  /* Contract初期化のための関数。contract名と同じにする */\n  function token(uint supply) {\n        coinBalanceOf[msg.sender] = supply;\n    }\n\n  /* コインを送るための関数 */\n    function sendCoin(address receiver, uint amount) returns(bool sufficient) {\n        if (coinBalanceOf[msg.sender] < amount) return false;\n        coinBalanceOf[msg.sender] -= amount;\n        coinBalanceOf[receiver] += amount;\n        CoinTransfer(msg.sender, receiver, amount);\n        return true;\n    }\n}\n```\n\nこのコントラクトから改行を削除します。テキストから改行を削除する方法については[こちらの記事](http://linux.just4fun.biz/%E9%80%86%E5%BC%95%E3%81%8DUNIX%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%8B%E3%82%89%E6%94%B9%E8%A1%8C%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B.html)を参考にしてください。\n\n```token_one_line.sol\ncontract token {    mapping (address => uint) public coinBalanceOf;    event CoinTransfer(address sender, address receiver, uint amount);  /* Contract初期化のための関数。contract名と同じにする */  function token(uint supply) {        coinBalanceOf[msg.sender] = supply;    }  /* コインを送るための関数 */    function sendCoin(address receiver, uint amount) returns(bool sufficient) {        if (coinBalanceOf[msg.sender] < amount) return false;        coinBalanceOf[msg.sender] -= amount;        coinBalanceOf[receiver] += amount;        CoinTransfer(msg.sender, receiver, amount);        return true;    }}\n```\n\n### コンパイル\n続いて、`solc`を用いてコントラクトをコンパイルします。\n\n```\n> var source = \"contract token {    mapping (address => uint) public coinBalanceOf;    event CoinTransfer(address sender, address receiver, uint amount);  /* Contract初期化のための関数。contract名と同じにする */  function token(uint supply) {        coinBalanceOf[msg.sender] = supply;    }  /* コインを送るための関数 */    function sendCoin(address receiver, uint amount) returns(bool sufficient) {        if (coinBalanceOf[msg.sender] < amount) return false;        coinBalanceOf[msg.sender] -= amount;        coinBalanceOf[receiver] += amount;        CoinTransfer(msg.sender, receiver, amount);        return true;    }}\"\n> var compiledSource = eth.compile.solidity(source)\n```\n\nこれでコンパイルは完了しました。続いてコンパイルしたコードをEthereumのネットワークに送信します。\n\n```\n> var abiDefinition = compiledSource.token.info.abiDefinition\n> var compiledContract = eth.contract(abiDefinition)\n> var supply = 10000\n> var contract = compiledContract.new(supply, {from:eth.accounts[0], data: compiledSource.token.code, gas:1000000})\n```\n\nこれでネットワークへの送信は完了しました。しかしまだマイニングは行われていないので、このコントラクトは承認されていません。そのためaddressもまだ未定です。\n\n```\n> contract\n{\n  address: undefined,\n  transactionHash: \"0x09b7b27e8d948b601ef1dd0548c7d33604c2fc7b8ee31d7d8e637f66da302a69\"\n}\n```\n\nマイニングが完了すると以下のようにaddressが付与されます。\n\n```\n> contract\n{\n  address: \"0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\",\n  transactionHash: \"0x09b7b27e8d948b601ef1dd0548c7d33604c2fc7b8ee31d7d8e637f66da302a69\",\n  CoinTransfer: function(),\n  allEvents: function(),\n  coinBalanceOf: function(),\n  sendCoin: function()\n}\n```\n\n### コントラクトのメソッドを用いる\n\nコントラクトで定義されているメソッドを呼び出してみましょう。\n以下のsendCoinメソッドは引数を2つとります。1つ目は受取主、2つ目は送金額です。\n\n```\n> contract.sendCoin.sendTransaction(eth.accounts[1], 1000, {from: eth.accounts[0]})\nI0511 22:09:00.939817    8397 xeth.go:1028] Tx(0xcd1003befe323aa1cdaee4e81e032b07cfe70fffc33400f46d033dc86cf4c4a1) to: 0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\n\"0xcd1003befe323aa1cdaee4e81e032b07cfe70fffc33400f46d033dc86cf4c4a1\"\n```\n\nメソッドがネットワークに送信されました。しかしまだマイニングされていないので、eth.accounts[0]の残高は10,000、eth.accounts[1]の残高は0のままです。\n\n```\n> contract.coinBalanceOf(eth.accounts[0])\n10000\n> contract.coinBalanceOf(eth.accounts[1])\n0\n```\n\nマイニングを行います。すると残高が以下のように変化します。\n\n```\n> contract.coinBalanceOf(eth.accounts[0])\n9000\n> contract.coinBalanceOf(eth.accounts[1])\n1000\n```\n\n以上がコントラクト内のメソッドの呼び出し方です。\n\n### 外部からコントラクトにアクセスする\n\n第三者がコントラクトにアクセスするには`AbiDefinition`と`address`が必要です。今回の場合は以下になります。\n\n```\n> abiDefinition \n[{\n    constant: false,\n    inputs: [{\n        name: \"receiver\",\n        type: \"address\"\n    }, {\n        name: \"amount\",\n        type: \"uint256\"\n    }],\n    name: \"sendCoin\",\n    outputs: [{\n        name: \"sufficient\",\n        type: \"bool\"\n    }],\n    type: \"function\"\n}, {\n    constant: true,\n    inputs: [{\n        name: \"\",\n        type: \"address\"\n    }],\n    name: \"coinBalanceOf\",\n    outputs: [{\n        name: \"\",\n        type: \"uint256\"\n    }],\n    type: \"function\"\n}, {\n    inputs: [{\n        name: \"supply\",\n        type: \"uint256\"\n    }],\n    type: \"constructor\"\n}, {\n    anonymous: false,\n    inputs: [{\n        indexed: false,\n        name: \"sender\",\n        type: \"address\"\n    }, {\n        indexed: false,\n        name: \"receiver\",\n        type: \"address\"\n    }, {\n        indexed: false,\n        name: \"amount\",\n        type: \"uint256\"\n    }],\n    name: \"CoinTransfer\",\n    type: \"event\"\n}]\n```\n\n```\n> contract.address\n\"0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\"\n```\n\n上記のデータを用いて、コントラクトにアクセスする変数を作成します。\n\n\n```\n> var theContract = eth.contract(abiDefinition).at(contract.address)\n> theContract\n{\n  address: \"0xb4ffc81cb032941a6cfd29f1f1817dc76413fae6\",\n  CoinTransfer: function(),\n  allEvents: function(),\n  coinBalanceOf: function(),\n  sendCoin: function()\n}\n```\n\nこれで第三者がコントラクトにアクセス出来るようになりました。\n\n\n### まとめ\n以上Solidityを使ったコントラクトの作成方法でした。次回はSolidityを用いたデリバティブの実装方法についてご説明致します。\n\n\n### 参考記事\nhttps://ethereum.gitbooks.io/frontier-guide/content/ether_transfer.html\nhttp://book.ethereum-jp.net/first_use/contract.html\nhttps://solidity.readthedocs.io/en/latest/index.html\nhttp://linux.just4fun.biz/%E9%80%86%E5%BC%95%E3%81%8DUNIX%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%8B%E3%82%89%E6%94%B9%E8%A1%8C%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B.html\n","coediting":false,"created_at":"2016-05-11T22:15:57+09:00","id":"28725215f7ad678b4b68","private":false,"tags":[{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"Solidityによるコントラクトの作成(1) - 基礎","updated_at":"2016-05-13T19:37:13+09:00","url":"http://qiita.com/toshikase/items/28725215f7ad678b4b68","user":{"description":"","facebook_id":"","followees_count":14,"followers_count":7,"github_login_name":"toshikase","id":"toshikase","items_count":10,"linkedin_id":"","location":"Tokyo Japan","name":"","organization":"Sendee Inc.","permanent_id":61031,"profile_image_url":"https://avatars.githubusercontent.com/u/6286361?v=3","twitter_screen_name":null,"website_url":""}},{"rendered_body":"<p>ただのコピペ</p>\n\n<p>引用元<br>\nここのContract Source<br>\n<a href=\"http://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code\" class=\"autolink\">http://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code</a></p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n*/\n\n\n/*\nBasic, standardized Token contract with no \"premine\". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address =&gt; uint256) balances;\n    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value &gt; 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] &gt;= _amount &amp;&amp; _amount &gt; 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] &gt;= _amount\n            &amp;&amp; allowed[_from][msg.sender] &gt;= _amount\n            &amp;&amp; _amount &gt; 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value &gt; 0 || (payOwnerOnly &amp;&amp; _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address =&gt; uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now &lt; closingTime &amp;&amp; msg.value &gt; 0\n            &amp;&amp; (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply &gt;= minTokensToCreate &amp;&amp; !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now &gt; closingTime &amp;&amp; !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance &gt;= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks &gt; now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days &gt; now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address =&gt; bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address =&gt; uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address =&gt; uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address =&gt; uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address =&gt; uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address =&gt; bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address =&gt; bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now &lt; closingTime + creationGracePeriod &amp;&amp; msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator &amp;&amp; (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value &gt; 0\n            || _debatingPeriod &lt; minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            &amp;&amp; (!isRecipientAllowed(_recipient) || (_debatingPeriod &lt;  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod &gt; 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now &lt; closingTime\n            || (msg.value &lt; proposalDeposit &amp;&amp; !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod &lt; now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now &gt;= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline &gt; proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open &amp;&amp; now &gt; p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now &lt; p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount &gt; actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length &gt;= 4 &amp;&amp; _transactionData[0] == 0x68\n            &amp;&amp; _transactionData[1] == 0x37 &amp;&amp; _transactionData[2] == 0xff\n            &amp;&amp; _transactionData[3] == 0x1e\n            &amp;&amp; quorum &lt; minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum &gt;= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum &gt; totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum &gt;= minQuorum(p.amount) &amp;&amp; p.yea &gt; p.nay &amp;&amp; proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) &amp;&amp; p.recipient != address(rewardAccount)\n                &amp;&amp; p.recipient != address(DAOrewardAccount)\n                &amp;&amp; p.recipient != address(extraBalance)\n                &amp;&amp; p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now &lt; p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now &gt; p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID &amp;&amp; blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance &lt; sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] &lt; rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] &lt; paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken &lt; DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            &amp;&amp; now &gt; closingTime\n            &amp;&amp; !isBlocked(msg.sender)\n            &amp;&amp; transferPaidOut(msg.sender, _to, _value)\n            &amp;&amp; super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            &amp;&amp; now &gt; closingTime\n            &amp;&amp; !isBlocked(_from)\n            &amp;&amp; transferPaidOut(_from, _to, _value)\n            &amp;&amp; super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut &gt; paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit &gt; (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                &amp;&amp; totalRewardToken &gt; extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet &lt; (now - quorumHalvingPeriod) || msg.sender == curator)\n            &amp;&amp; lastTimeMinQuorumMet &lt; (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now &gt; p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}\n\n\n</pre></div></div>\n","body":"\nただのコピペ\n\n引用元\nここのContract Source\nhttp://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code\n\n```\n/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no \"premine\". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}\n\n\n```\n","coediting":false,"created_at":"2016-05-06T02:08:26+09:00","id":"dd26398fa4d1f5b7758b","private":false,"tags":[{"name":"Ethereum","versions":[]},{"name":"DAO","versions":[]}],"title":"DAOのSolidityソース","updated_at":"2016-05-06T02:08:26+09:00","url":"http://qiita.com/satons/items/dd26398fa4d1f5b7758b","user":{"description":null,"facebook_id":null,"followees_count":2,"followers_count":7,"github_login_name":"starcharles","id":"satons","items_count":11,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":80546,"profile_image_url":"https://avatars.githubusercontent.com/u/7988311?v=3","twitter_screen_name":null,"website_url":null}},{"rendered_body":"<p>目次<br>\nwiki/[Japanese]-Ethereum-TOC.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Ethereum-TOC.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Ethereum-TOC.md</a></p>\n\n<p>開発チュートリアル<br>\nwiki/[Japanese]--Ethereum-Development-Tutorial.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D--Ethereum-Development-Tutorial.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D--Ethereum-Development-Tutorial.md</a></p>\n\n<p>Solidityチュートリアル<br>\nwiki/[Japanese]-Solidity-Tutorial.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Solidity-Tutorial.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Solidity-Tutorial.md</a></p>\n\n<p>Javascript-API<br>\nwiki/[Japanese]-Javascript-API.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Javascript-API.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Javascript-API.md</a></p>\n\n<p>暗号通過における課題<br>\nwiki/[Japanese]-Cryptocurrency-Current-Problems.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Cryptocurrency-Current-Problems.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Cryptocurrency-Current-Problems.md</a></p>\n\n<p>？？？<br>\nwiki/[Japanese]-Whisper-（ウィスパー）.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Whisper-%EF%BC%88%E3%82%A6%E3%82%A3%E3%82%B9%E3%83%91%E3%83%BC%EF%BC%89.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Whisper-%EF%BC%88%E3%82%A6%E3%82%A3%E3%82%B9%E3%83%91%E3%83%BC%EF%BC%89.md</a></p>\n\n<p>？？？<br>\nwiki/[Japanese]-HPOC_2015.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-HPOC_2015.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-HPOC_2015.md</a></p>\n\n<p>ライセンスについて<br>\nwiki/[Japanese]--License.md at master · ethereum/wiki · GitHub<br>\n<a href=\"https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D--License.md\" class=\"autolink\">https://github.com/ethereum/wiki/blob/master/%5BJapanese%5D--License.md</a></p>\n","body":"目次\nwiki/[Japanese]-Ethereum-TOC.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Ethereum-TOC.md\n\n開発チュートリアル\nwiki/[Japanese]--Ethereum-Development-Tutorial.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D--Ethereum-Development-Tutorial.md\n\nSolidityチュートリアル\nwiki/[Japanese]-Solidity-Tutorial.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Solidity-Tutorial.md\n\nJavascript-API\nwiki/[Japanese]-Javascript-API.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Javascript-API.md\n\n暗号通過における課題\nwiki/[Japanese]-Cryptocurrency-Current-Problems.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Cryptocurrency-Current-Problems.md\n\n？？？\nwiki/[Japanese]-Whisper-（ウィスパー）.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-Whisper-%EF%BC%88%E3%82%A6%E3%82%A3%E3%82%B9%E3%83%91%E3%83%BC%EF%BC%89.md\n\n？？？\nwiki/[Japanese]-HPOC_2015.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D-HPOC_2015.md\n\nライセンスについて\nwiki/[Japanese]--License.md at master · ethereum/wiki · GitHub\nhttps://github.com/ethereum/wiki/blob/master/%5BJapanese%5D--License.md\n","coediting":false,"created_at":"2016-04-21T18:03:37+09:00","id":"fd19bb9548a1af646f48","private":false,"tags":[{"name":"Ethereum","versions":[]}],"title":"Ethereum公式Wikiのうち、日本語化されているもの","updated_at":"2016-04-22T13:06:24+09:00","url":"http://qiita.com/maruyam-a/items/fd19bb9548a1af646f48","user":{"description":"","facebook_id":"","followees_count":16,"followers_count":19,"github_login_name":null,"id":"maruyam-a","items_count":16,"linkedin_id":"","location":"Tokyo, Japan","name":"k maruyama","organization":"DTS corporation","permanent_id":38582,"profile_image_url":"https://pbs.twimg.com/profile_images/443981822301450240/kCZlTrn0_normal.jpeg","twitter_screen_name":"maruyam_a","website_url":""}},{"rendered_body":"<p>Geth helpの備忘録</p>\n\n<p>'16 4/11時点<br>\n<strong>VERSION</strong> : 1.3.6</p>\n\n<h2>\n<span id=\"usage\" class=\"fragment\"></span><a href=\"#usage\"><i class=\"fa fa-link\"></i></a>USAGE:</h2>\n\n<p>geth [options] command [command options] [arguments...]</p>\n\n<h2>\n<span id=\"commands\" class=\"fragment\"></span><a href=\"#commands\"><i class=\"fa fa-link\"></i></a>COMMANDS:</h2>\n\n<p>recover :    Attempts to recover a corrupted database by setting a new block by number or hash<br>\n   blocktest :  loads a block test file<br>\n   import :     import a blockchain file<br>\n   export : export blockchain into file<br>\n   upgradedb :  upgrade chainblock database<br>\n   removedb :   Remove blockchain and state databases<br>\n   dump :       dump a specific block from storage<br>\n   monitor :    Geth Monitor: node metrics monitoring and visualization<br>\n   makedag :    generate ethash dag (for testing)<br>\n   gpuinfo :    gpuinfo<br>\n   gpubench :   benchmark GPU<br>\n   version :    print ethereum version numbers<br>\n   wallet : ethereum presale wallet<br>\n   account :    manage accounts<br>\n   console :    Geth Console: interactive JavaScript environment<br>\n   attach : Geth Console: interactive JavaScript environment (connect to node)<br>\n   js :     executes the given JavaScript files in the Geth JavaScript VM<br>\n   help, h :    Shows a list of commands or help for one command</p>\n\n<h2>\n<span id=\"ethereum-options\" class=\"fragment\"></span><a href=\"#ethereum-options\"><i class=\"fa fa-link\"></i></a>ETHEREUM OPTIONS:</h2>\n\n<p>--datadir : \"/home/vagrant/.ethereum\" Data directory for the databases and keystore<br>\n  --networkid : \"1\"         Network identifier (integer, 0=Olympic, 1=Frontier, 2=Morden)<br>\n任意の正の整数のID(0,1,2を除く)を指定することで、ライブ・ネットとは異なるネットワークを立ち上げられる。</p>\n\n<p>--olympic             Olympic network: pre-configured pre-release test network<br>\n  --testnet             Morden network: pre-configured test network with modified starting nonces (replay protection)<br>\n  --dev :                   Developer mode: pre-configured private network with several debugging flags<br>\n  --genesis :               Insert/overwrite the genesis block (JSON format)<br>\n  --identity :              Custom node name<br>\n  --fast :              Enable fast syncing through state downloads<br>\n  --lightkdf :              Reduce key-derivation RAM &amp; CPU usage at some expense of KDF strength<br>\n  --cache : \"0\"             Megabytes of memory allocated to internal caching (min 16MB / database forced)<br>\n  --blockchainversion : \"3\"     Blockchain version (integer)</p>\n\n<p>ACCOUNT OPTIONS:<br>\n  --unlock :    Unlock an account (may be creation index) until this program exits (prompts for password)<br>\n  --password :  Password file to use with options/subcommands needing a pass phrase</p>\n\n<h2>\n<span id=\"api-and-console-options\" class=\"fragment\"></span><a href=\"#api-and-console-options\"><i class=\"fa fa-link\"></i></a>API AND CONSOLE OPTIONS:</h2>\n\n<p>--rpc :                                   Enable the HTTP-RPC server<br>\n  --rpcaddr : \"127.0.0.1\"                           HTTP-RPC server listening interface<br>\n  --rpcport : \"8545\"                            HTTP-RPC server listening port<br>\n  --rpcapi : \"db,eth,net,web3\"                      API's offered over the HTTP-RPC interface<br>\n  --ipcdisable :                                Disable the IPC-RPC server<br>\n  --ipcapi : \"admin,db,eth,debug,miner,net,shh,txpool,personal,web3\"    API's offered over the IPC-RPC interface<br>\n  --ipcpath : \"/home/vagrant/.ethereum/geth.ipc\"                Filename for IPC socket/pipe<br>\n  --rpccorsdomain :                             Domains from which to accept cross origin requests (browser enforced)<br>\n  --jspath : \".\"                                JavaSript root path for <code>loadScript</code> and document root for <code>admin.httpGet</code><br>\n  --exec :                              Execute JavaScript statement (only in combination with console/attach)</p>\n\n<h2>\n<span id=\"networking-options\" class=\"fragment\"></span><a href=\"#networking-options\"><i class=\"fa fa-link\"></i></a>NETWORKING OPTIONS:</h2>\n\n<p>--bootnodes :         Space-separated enode URLs for P2P discovery bootstrap<br>\n  --port : \"30303\"  Network listening port<br>\n  --maxpeers : \"25\" Maximum number of network peers (network disabled if set to 0)<br>\n  --maxpendpeers : \"0\"  Maximum number of pending connection attempts (defaults used if set to 0)<br>\n  --nat : \"any\"     NAT port mapping mechanism (any|none|upnp|pmp|extip:)<br>\n  --nodiscover :        Disables the peer discovery mechanism (manual peer addition)<br>\n  --nodekey :       P2P node key file<br>\n  --nodekeyhex :        P2P node key as hex (for testing)</p>\n\n<h2>\n<span id=\"miner-options\" class=\"fragment\"></span><a href=\"#miner-options\"><i class=\"fa fa-link\"></i></a>MINER OPTIONS:</h2>\n\n<p>--mine :          Enable mining<br>\n  --minerthreads : \"1\"      Number of CPU threads to use for mining<br>\n  --minergpus :             List of GPUs to use for mining (e.g. '0,1' will use the first two GPUs found)<br>\n  --autodag :           Enable automatic DAG pregeneration<br>\n  --etherbase : \"0\"     Public address for block mining rewards (default = first account created)<br>\n  --gasprice : \"20000000000\"    Minimal gas price to accept for mining a transactions<br>\n  --extradata :             Block extra data set by the miner (default = client version)</p>\n\n<h2>\n<span id=\"gas-price-oracle-options\" class=\"fragment\"></span><a href=\"#gas-price-oracle-options\"><i class=\"fa fa-link\"></i></a>GAS PRICE ORACLE OPTIONS:</h2>\n\n<p>--gpomin : \"20000000000\"  Minimum suggested gas price<br>\n  --gpomax : \"500000000000\" Maximum suggested gas price<br>\n  --gpofull : \"80\"      Full block threshold for gas price calculation (%)<br>\n  --gpobasedown : \"10\"      Suggested gas price base step down ratio (1/1000)<br>\n  --gpobaseup : \"100\"       Suggested gas price base step up ratio (1/1000)<br>\n  --gpobasecf : \"110\"       Suggested gas price base correction factor (%)</p>\n\n<h2>\n<span id=\"virtual-machine-options\" class=\"fragment\"></span><a href=\"#virtual-machine-options\"><i class=\"fa fa-link\"></i></a>VIRTUAL MACHINE OPTIONS:</h2>\n\n<p>--vmdebug :       Virtual Machine debug output<br>\n  --jitvm :     Enable the JIT VM<br>\n  --forcejit :      Force the JIT VM to take precedence<br>\n  --jitcache : \"64\" Amount of cached JIT VM programs</p>\n\n<h2>\n<span id=\"logging-and-debugging-options\" class=\"fragment\"></span><a href=\"#logging-and-debugging-options\"><i class=\"fa fa-link\"></i></a>LOGGING AND DEBUGGING OPTIONS:</h2>\n\n<p>--verbosity : \"3\" Logging verbosity: 0-6 (0=silent, 1=error, 2=warn, 3=info, 4=core, 5=debug, 6=debug detail)<br>\n  --vmodule : \"\"        Per-module verbosity: comma-separated list of =, where  is file literal or a glog pattern<br>\n  --backtrace : \":0\"    Request a stack trace at a specific logging statement (e.g. \"block.go:271\")<br>\n  --logfile :       Log output file within the data dir (default = no log file generated)<br>\n  --pprof :     Enable the profiling server on localhost<br>\n  --pprofport : \"6060\"  Profile server listening port<br>\n  --metrics :       Enable metrics collection and reporting</p>\n\n<h2>\n<span id=\"experimental-options\" class=\"fragment\"></span><a href=\"#experimental-options\"><i class=\"fa fa-link\"></i></a>EXPERIMENTAL OPTIONS:</h2>\n\n<p>--shh :       Enable Whisper<br>\n  --natspec :   Enable NatSpec confirmation notice</p>\n\n<h2>\n<span id=\"miscellaneous-options\" class=\"fragment\"></span><a href=\"#miscellaneous-options\"><i class=\"fa fa-link\"></i></a>MISCELLANEOUS OPTIONS:</h2>\n\n<p>--solc : \"solc\"   Solidity compiler command to be used<br>\n  --help, -h :  show help</p>\n","body":"Geth helpの備忘録\n\n'16 4/11時点\n**VERSION** : 1.3.6\n\n## USAGE:\n   geth [options] command [command options] [arguments...]\n\n## COMMANDS:\n   recover :\tAttempts to recover a corrupted database by setting a new block by number or hash\n   blocktest :\tloads a block test file\n   import : \timport a blockchain file\n   export :\texport blockchain into file\n   upgradedb :\tupgrade chainblock database\n   removedb :\tRemove blockchain and state databases\n   dump :\t\tdump a specific block from storage\n   monitor :\tGeth Monitor: node metrics monitoring and visualization\n   makedag :\tgenerate ethash dag (for testing)\n   gpuinfo :\tgpuinfo\n   gpubench :\tbenchmark GPU\n   version :\tprint ethereum version numbers\n   wallet :\tethereum presale wallet\n   account :\tmanage accounts\n   console :\tGeth Console: interactive JavaScript environment\n   attach :\tGeth Console: interactive JavaScript environment (connect to node)\n   js :\t\texecutes the given JavaScript files in the Geth JavaScript VM\n   help, h :\tShows a list of commands or help for one command\n\n## ETHEREUM OPTIONS:\n  --datadir : \"/home/vagrant/.ethereum\"\tData directory for the databases and keystore\n  --networkid : \"1\"\t\t\tNetwork identifier (integer, 0=Olympic, 1=Frontier, 2=Morden)\n任意の正の整数のID(0,1,2を除く)を指定することで、ライブ・ネットとは異なるネットワークを立ち上げられる。\n\n  --olympic\t\t\t\tOlympic network: pre-configured pre-release test network\n  --testnet\t\t\t\tMorden network: pre-configured test network with modified starting nonces (replay protection)\n  --dev :\t\t\t\t\tDeveloper mode: pre-configured private network with several debugging flags\n  --genesis : \t\t\t\tInsert/overwrite the genesis block (JSON format)\n  --identity : \t\t\t\tCustom node name\n  --fast :\t\t\t\tEnable fast syncing through state downloads\n  --lightkdf :\t\t\t\tReduce key-derivation RAM & CPU usage at some expense of KDF strength\n  --cache : \"0\"\t\t\t\tMegabytes of memory allocated to internal caching (min 16MB / database forced)\n  --blockchainversion : \"3\"\t\tBlockchain version (integer)\n\nACCOUNT OPTIONS:\n  --unlock : \tUnlock an account (may be creation index) until this program exits (prompts for password)\n  --password : \tPassword file to use with options/subcommands needing a pass phrase\n\n## API AND CONSOLE OPTIONS:\n  --rpc :\t\t\t\t\t\t\t\t\tEnable the HTTP-RPC server\n  --rpcaddr : \"127.0.0.1\"\t\t\t\t\t\t\tHTTP-RPC server listening interface\n  --rpcport : \"8545\"\t\t\t\t\t\t\tHTTP-RPC server listening port\n  --rpcapi : \"db,eth,net,web3\"\t\t\t\t\t\tAPI's offered over the HTTP-RPC interface\n  --ipcdisable :\t\t\t\t\t\t\t\tDisable the IPC-RPC server\n  --ipcapi : \"admin,db,eth,debug,miner,net,shh,txpool,personal,web3\"\tAPI's offered over the IPC-RPC interface\n  --ipcpath : \"/home/vagrant/.ethereum/geth.ipc\"\t\t\t\tFilename for IPC socket/pipe\n  --rpccorsdomain : \t\t\t\t\t\t\tDomains from which to accept cross origin requests (browser enforced)\n  --jspath : \".\"\t\t\t\t\t\t\t\tJavaSript root path for `loadScript` and document root for `admin.httpGet`\n  --exec : \t\t\t\t\t\t\t\tExecute JavaScript statement (only in combination with console/attach)\n\n## NETWORKING OPTIONS:\n  --bootnodes : \t\tSpace-separated enode URLs for P2P discovery bootstrap\n  --port : \"30303\"\tNetwork listening port\n  --maxpeers : \"25\"\tMaximum number of network peers (network disabled if set to 0)\n  --maxpendpeers : \"0\"\tMaximum number of pending connection attempts (defaults used if set to 0)\n  --nat : \"any\"\t\tNAT port mapping mechanism (any|none|upnp|pmp|extip:<IP>)\n  --nodiscover :\t\tDisables the peer discovery mechanism (manual peer addition)\n  --nodekey : \t\tP2P node key file\n  --nodekeyhex : \t\tP2P node key as hex (for testing)\n\n## MINER OPTIONS:\n  --mine :\t\t\tEnable mining\n  --minerthreads : \"1\"\t\tNumber of CPU threads to use for mining\n  --minergpus : \t\t\tList of GPUs to use for mining (e.g. '0,1' will use the first two GPUs found)\n  --autodag :\t\t\tEnable automatic DAG pregeneration\n  --etherbase : \"0\"\t\tPublic address for block mining rewards (default = first account created)\n  --gasprice : \"20000000000\"\tMinimal gas price to accept for mining a transactions\n  --extradata : \t\t\tBlock extra data set by the miner (default = client version)\n\n## GAS PRICE ORACLE OPTIONS:\n  --gpomin : \"20000000000\"\tMinimum suggested gas price\n  --gpomax : \"500000000000\"\tMaximum suggested gas price\n  --gpofull : \"80\"\t\tFull block threshold for gas price calculation (%)\n  --gpobasedown : \"10\"\t\tSuggested gas price base step down ratio (1/1000)\n  --gpobaseup : \"100\"\t\tSuggested gas price base step up ratio (1/1000)\n  --gpobasecf : \"110\"\t\tSuggested gas price base correction factor (%)\n\n## VIRTUAL MACHINE OPTIONS:\n  --vmdebug :\t\tVirtual Machine debug output\n  --jitvm :\t\tEnable the JIT VM\n  --forcejit :\t\tForce the JIT VM to take precedence\n  --jitcache : \"64\"\tAmount of cached JIT VM programs\n\n## LOGGING AND DEBUGGING OPTIONS:\n  --verbosity : \"3\"\tLogging verbosity: 0-6 (0=silent, 1=error, 2=warn, 3=info, 4=core, 5=debug, 6=debug detail)\n  --vmodule : \"\"\t\tPer-module verbosity: comma-separated list of <module>=<level>, where <module> is file literal or a glog pattern\n  --backtrace : \":0\"\tRequest a stack trace at a specific logging statement (e.g. \"block.go:271\")\n  --logfile : \t\tLog output file within the data dir (default = no log file generated)\n  --pprof :\t\tEnable the profiling server on localhost\n  --pprofport : \"6060\"\tProfile server listening port\n  --metrics :\t\tEnable metrics collection and reporting\n\n## EXPERIMENTAL OPTIONS:\n  --shh :\t\tEnable Whisper\n  --natspec :\tEnable NatSpec confirmation notice\n\n## MISCELLANEOUS OPTIONS:\n  --solc : \"solc\"\tSolidity compiler command to be used\n  --help, -h :\tshow help\n","coediting":false,"created_at":"2016-04-11T11:34:12+09:00","id":"38c0f6c469765a1b0b50","private":false,"tags":[{"name":"Ethereum","versions":[]}],"title":"Geth 立ち上げコマンド一覧","updated_at":"2016-04-12T14:47:19+09:00","url":"http://qiita.com/toshikase/items/38c0f6c469765a1b0b50","user":{"description":"","facebook_id":"","followees_count":14,"followers_count":7,"github_login_name":"toshikase","id":"toshikase","items_count":10,"linkedin_id":"","location":"Tokyo Japan","name":"","organization":"Sendee Inc.","permanent_id":61031,"profile_image_url":"https://avatars.githubusercontent.com/u/6286361?v=3","twitter_screen_name":null,"website_url":""}},{"rendered_body":"<p>Ethereumのブロックチェインにプログラムからアクセスする場合、 <code>web3.js</code> とか Node.js用ライブラリとかのJavaScriptAPI(<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API\" class=\"autolink\">https://github.com/ethereum/wiki/wiki/JavaScript-API</a>) を使うのが一般的だ（Ethereum自体がまだそれほど一般的ではないのは置いておいて・・・）。documentも結構が充実しているし、分かりやすい構造なので、とりあえずEthereumに繋げられればいいやというときには、もうこの一択。<br><br>\nんが、使用言語など、作る際の制約が制約が色々出てくると、JSON-RPC(<a href=\"https://github.com/ethereum/wiki/wiki/JSON-RPC\" class=\"autolink\">https://github.com/ethereum/wiki/wiki/JSON-RPC</a> ) 経由でのアクセスが必要となってくる。<br><br>\nJavaScriptAPIも、JSON-RPCをJavaScriptが持つキャッチーかつフニャフニャな衣で包んでるだけなので（内部は完全にJSON-RPC）、そっちでできることは、全てJSON-RPCでも出来る。<br><br>\nまずは <code>Contract</code> を作らないと始まらないということで、とりあえず今回は、 <code>Contract</code> を作る方法を書き殴ります。</p>\n\n<h2>\n<span id=\"準備\" class=\"fragment\"></span><a href=\"#%E6%BA%96%E5%82%99\"><i class=\"fa fa-link\"></i></a>準備</h2>\n\n<h3>\n<span id=\"contractのコードを書く\" class=\"fragment\"></span><a href=\"#contract%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F\"><i class=\"fa fa-link\"></i></a>Contractのコードを書く</h3>\n\n<p>コンストラクタにパラメータがある場合のアクセスにもの凄く苦戦したので、</p>\n\n<ul>\n<li>コンストラクタ無し</li>\n<li>パラメータ付きのコンストラクタあり</li>\n</ul>\n\n<p>の２つの <code>Contract</code> 準備したものとして説明する。下はサンプル。言語は <code>Solidity</code> 。</p>\n\n<div class=\"code-frame\" data-lang=\"コンストラクタなし\"><div class=\"highlight\"><pre>\ncontract Nassy {\n    // ... functionとか変数とか\n}\n\n</pre></div></div>\n\n<div class=\"code-frame\" data-lang=\"パラメータ付コンストラクタあり\"><div class=\"highlight\"><pre>\ncontract Ariinu {\n    function Ariinu(int nanika, address dokoka) {\n        // ... 何かの処理\n    } \n    // ... functionとか変数とか\n} \n</pre></div></div>\n\n<h3>\n<span id=\"コードをゲット\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E3%82%B2%E3%83%83%E3%83%88\"><i class=\"fa fa-link\"></i></a>コードをゲット</h3>\n\n<p>で、こいつをコンパイル。コンパイルは、 <code>cpp-ethereum</code> の <code>solc</code> コマンドで行うか、 JavaScriptAPIの、 <code>web3.eth.compile.solidity()</code> ファンクション( <a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethcompilesolidity\" class=\"autolink\">https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethcompilesolidity</a> )から行う。<br><br>\nで、出来上がった、0からfの文字が繰り返される諸行無常（ZAZEN-BOYSを聴きながら書いてる・・・）のコードを退避。自分は、<code>solc</code>の実行からできたコードをGO言語のソースコードにまで落としこむスクリプトを作って、どっからでもかかってこい状態にしている。  </p>\n\n<h2>\n<span id=\"ブロックチェイン上に作成\" class=\"fragment\"></span><a href=\"#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%83%81%E3%82%A7%E3%82%A4%E3%83%B3%E4%B8%8A%E3%81%AB%E4%BD%9C%E6%88%90\"><i class=\"fa fa-link\"></i></a>ブロックチェイン上に作成</h2>\n\n<h3>\n<span id=\"コンストラクタなし\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%81%AA%E3%81%97\"><i class=\"fa fa-link\"></i></a>コンストラクタなし</h3>\n\n<p>コンストラクタなし（または、パタメータなしコンストラクタ）の方は、割とスムーズに作成できた記憶がある。<br><br>\nこんな感じ。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[\n\n{\n  \"from\": \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",// 作成アカウントアドレス（左記はテキトー)\n  \"gas\": \"0x76c0\", // 作成に使っていい最大GAS値,\n  \"data\": \"0xd46e8dd6...\" // ゲットしたコード\n}\n\n\n], \"id\":(どのコールのレスポンスかを判別するためのテキトーな番号)}\n\n</pre></div></div>\n\n<p>よし、これで行ってみよう。GASが不足していなければ、デキるはず。</p>\n\n<h3>\n<span id=\"パラメータ付きコンストラクタあり\" class=\"fragment\"></span><a href=\"#%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E4%BB%98%E3%81%8D%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%81%82%E3%82%8A\"><i class=\"fa fa-link\"></i></a>パラメータ付きコンストラクタあり</h3>\n\n<p>とりあえず、パラメータありコンストラクタのコードを書いてみたものの、これ、使う時、コンストラクタのパラメータ、どこで指定すんの？？ と、JSON-RPCの説明を片っ端から読み漁ったけど、書いていない。<br><br>\n仕方なく、24時間体制でCRYPTOジャンキー野郎の吹き溜まりと化しているGITTER( <a href=\"https://gitter.im/orgs/ethereum/rooms\" class=\"autolink\">https://gitter.im/orgs/ethereum/rooms</a> )で、ルー大柴ばりの英語で質問すると、１時間以上放置された後（多分誰もわからないんじゃ・・・）、こーやんじゃねーの的な回答が。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n\"params\":[\n\n{\n  \"from\": \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",// 作成アカウントアドレス（左記はテキトー)\n  \"gas\": \"0x76c0\", // 作成に使っていい最大GAS値,\n  \"data\": \"0xd46e8dd6...\" // ゲットしたコード   \n},\n{\n  \"data\":(パラメータ値)\n}\n]\n\n</pre></div></div>\n\n<p>やってみたけど、出来ない。色んなパラメータ追加したりしてみたけど、全くできない。<br>\nちなみに下の素っ気ないメッセージが出る。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n{\"code\":-32602,\"message\":\"insufficient params, want 1 have 2\"}\n</pre></div></div>\n\n<p>仕方なく、 <code>web3.js</code> を解析・・・・  </p>\n\n<p>そして試した結果、こうすることが分かった。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n\"params\":[\n\n{\n  \"from\": \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",// 作成アカウントアドレス（左記はテキトー)\n  \"gas\": \"0x76c0\", // 作成に使っていい最大GAS値,\n  \"data\": \"0xd46e8dd6...\" // ゲットしたコード ＋ パラメータ\n}\n]\n</pre></div></div>\n\n<p>コンパイルしたコードの後にパラメータ値をペタッとくっつけるのだ。このパラメータ値は、ルールに則って0からfの文字で繰り返す諸行無常加工をする。(そのルール：<a href=\"https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector-and-argument-encoding\" class=\"autolink\">https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector-and-argument-encoding</a> )  </p>\n\n<p>よし、これで行ってみよう。GASが不足していなければ、デキるはず。  </p>\n","body":"Ethereumのブロックチェインにプログラムからアクセスする場合、 ` web3.js ` とか Node.js用ライブラリとかのJavaScriptAPI(https://github.com/ethereum/wiki/wiki/JavaScript-API) を使うのが一般的だ（Ethereum自体がまだそれほど一般的ではないのは置いておいて・・・）。documentも結構が充実しているし、分かりやすい構造なので、とりあえずEthereumに繋げられればいいやというときには、もうこの一択。  \nんが、使用言語など、作る際の制約が制約が色々出てくると、JSON-RPC(https://github.com/ethereum/wiki/wiki/JSON-RPC ) 経由でのアクセスが必要となってくる。  \nJavaScriptAPIも、JSON-RPCをJavaScriptが持つキャッチーかつフニャフニャな衣で包んでるだけなので（内部は完全にJSON-RPC）、そっちでできることは、全てJSON-RPCでも出来る。  \nまずは `Contract` を作らないと始まらないということで、とりあえず今回は、 `Contract` を作る方法を書き殴ります。\n\n## 準備\n\n### Contractのコードを書く\n\nコンストラクタにパラメータがある場合のアクセスにもの凄く苦戦したので、\n\n* コンストラクタ無し\n* パラメータ付きのコンストラクタあり\n\nの２つの `Contract` 準備したものとして説明する。下はサンプル。言語は `Solidity` 。\n\n``` コンストラクタなし\ncontract Nassy {\n\t// ... functionとか変数とか\n}\n\n```\n\n``` パラメータ付コンストラクタあり\ncontract Ariinu {\n\tfunction Ariinu(int nanika, address dokoka) {\n\t\t// ... 何かの処理\n\t} \n\t// ... functionとか変数とか\n} \n```\n\n### コードをゲット\n\nで、こいつをコンパイル。コンパイルは、 `cpp-ethereum` の `solc` コマンドで行うか、 JavaScriptAPIの、 `web3.eth.compile.solidity()` ファンクション( https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethcompilesolidity )から行う。  \nで、出来上がった、0からfの文字が繰り返される諸行無常（ZAZEN-BOYSを聴きながら書いてる・・・）のコードを退避。自分は、`solc`の実行からできたコードをGO言語のソースコードにまで落としこむスクリプトを作って、どっからでもかかってこい状態にしている。  \n\n## ブロックチェイン上に作成\n\n### コンストラクタなし\n\nコンストラクタなし（または、パタメータなしコンストラクタ）の方は、割とスムーズに作成できた記憶がある。  \nこんな感じ。\n\n```\n{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[\n\n{\n  \"from\": \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",// 作成アカウントアドレス（左記はテキトー)\n  \"gas\": \"0x76c0\", // 作成に使っていい最大GAS値,\n  \"data\": \"0xd46e8dd6...\" // ゲットしたコード\n}\n\n\n], \"id\":(どのコールのレスポンスかを判別するためのテキトーな番号)}\n\n```\n\nよし、これで行ってみよう。GASが不足していなければ、デキるはず。\n\n\n### パラメータ付きコンストラクタあり\n\nとりあえず、パラメータありコンストラクタのコードを書いてみたものの、これ、使う時、コンストラクタのパラメータ、どこで指定すんの？？ と、JSON-RPCの説明を片っ端から読み漁ったけど、書いていない。   \n仕方なく、24時間体制でCRYPTOジャンキー野郎の吹き溜まりと化しているGITTER( https://gitter.im/orgs/ethereum/rooms )で、ルー大柴ばりの英語で質問すると、１時間以上放置された後（多分誰もわからないんじゃ・・・）、こーやんじゃねーの的な回答が。\n\n```\n\"params\":[\n\n{\n  \"from\": \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",// 作成アカウントアドレス（左記はテキトー)\n  \"gas\": \"0x76c0\", // 作成に使っていい最大GAS値,\n  \"data\": \"0xd46e8dd6...\" // ゲットしたコード\t\n},\n{\n  \"data\":(パラメータ値)\n}\n]\n\n```\n\nやってみたけど、出来ない。色んなパラメータ追加したりしてみたけど、全くできない。\nちなみに下の素っ気ないメッセージが出る。\n\n```\n{\"code\":-32602,\"message\":\"insufficient params, want 1 have 2\"}\n```\n  \n仕方なく、 `web3.js` を解析・・・・  \n\nそして試した結果、こうすることが分かった。\n\n```\n\"params\":[\n\n{\n  \"from\": \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",// 作成アカウントアドレス（左記はテキトー)\n  \"gas\": \"0x76c0\", // 作成に使っていい最大GAS値,\n  \"data\": \"0xd46e8dd6...\" // ゲットしたコード ＋ パラメータ\n}\n]\n```\n\nコンパイルしたコードの後にパラメータ値をペタッとくっつけるのだ。このパラメータ値は、ルールに則って0からfの文字で繰り返す諸行無常加工をする。(そのルール：https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector-and-argument-encoding )  \n\nよし、これで行ってみよう。GASが不足していなければ、デキるはず。  \n\n\n","coediting":false,"created_at":"2016-04-02T12:57:14+09:00","id":"e5aa007374ce753ebfd5","private":false,"tags":[{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"JSON-RPC経由でEthereumのContractを作る","updated_at":"2016-04-02T12:57:14+09:00","url":"http://qiita.com/kenmazsyma/items/e5aa007374ce753ebfd5","user":{"description":"","facebook_id":"","followees_count":1,"followers_count":4,"github_login_name":"kenmazsyma","id":"kenmazsyma","items_count":5,"linkedin_id":"","location":"東京都江東区","name":"Mazsyma Ken","organization":"フリーランス","permanent_id":39724,"profile_image_url":"https://pbs.twimg.com/profile_images/686386343509794818/FjFrXHPV_normal.jpg","twitter_screen_name":"kenmazsyma","website_url":""}},{"rendered_body":"<p>最近、Ethereumを触っていまして、contract作成用のSolidityという言語を触っています。</p>\n\n<p>下記のページにSolidityの説明が詳細に載っています。<br>\n<a href=\"https://solidity.readthedocs.org/en/latest/solidity-by-example.html\">Solidity by example</a></p>\n\n<p>読み進めてる途中、mappingというのが出てきまして、</p>\n\n<div class=\"code-frame\" data-lang=\"lang\"><div class=\"highlight\"><pre>\nmapping(address =&gt; Voter) public voters;\n</pre></div></div>\n\n<p>これが一体何なのか、何となく分からなかったのですが、３月半ばにEthereumのサイトが一新されまして、その中にcontract作成の例が複数のってあり、説明を見つけました。</p>\n\n<p><a href=\"https://www.ethereum.org/token\">CREATE YOUR OWN CRYPTO-CURRENCY WITH ETHEREUM</a></p>\n\n<p>上記ページのはじめの方に、<br>\nA mapping means an associative array, where you associate addresses with balances.<br>\nと書いてあり、なるほど連想配列か、と理解。</p>\n\n<p>つまり下記の例だと、</p>\n\n<div class=\"code-frame\" data-lang=\"lang\"><div class=\"highlight\"><pre>\nmapping (address =&gt; uint256) public balanceOf;\nmapping (address =&gt; bool) public frozenAccount; \nmapping (address =&gt; mapping (address =&gt; uint256)) public allowance;\nmapping (address =&gt; mapping (address =&gt; uint256)) public spentAllowance;\n</pre></div></div>\n\n<p>balanceOfはaddressを添字としたuint256型の配列、frozenAccountはaddressを添字とたboolean型配列、allowanceとspentAllowanceはaddressを添字としたuint256型の二次元配列、ということですね。</p>\n\n<p>Ethereumのページのどこかにわかり易い説明が載っているのかもしれませんが、私が見つけることができたのはこの説明だけでしたので、こちらに簡単にまとめました。</p>\n\n<p>ご参考になれば幸いです。</p>\n","body":"最近、Ethereumを触っていまして、contract作成用のSolidityという言語を触っています。\n\n下記のページにSolidityの説明が詳細に載っています。\n[Solidity by example](https://solidity.readthedocs.org/en/latest/solidity-by-example.html)\n\n読み進めてる途中、mappingというのが出てきまして、\n\n```lang:\nmapping(address => Voter) public voters;\n```\n\nこれが一体何なのか、何となく分からなかったのですが、３月半ばにEthereumのサイトが一新されまして、その中にcontract作成の例が複数のってあり、説明を見つけました。\n\n[CREATE YOUR OWN CRYPTO-CURRENCY WITH ETHEREUM]\n(https://www.ethereum.org/token)\n\n上記ページのはじめの方に、\nA mapping means an associative array, where you associate addresses with balances.\nと書いてあり、なるほど連想配列か、と理解。\n\nつまり下記の例だと、\n\n```lang\nmapping (address => uint256) public balanceOf;\nmapping (address => bool) public frozenAccount; \nmapping (address => mapping (address => uint256)) public allowance;\nmapping (address => mapping (address => uint256)) public spentAllowance;\n```\n\nbalanceOfはaddressを添字としたuint256型の配列、frozenAccountはaddressを添字とたboolean型配列、allowanceとspentAllowanceはaddressを添字としたuint256型の二次元配列、ということですね。\n\n\nEthereumのページのどこかにわかり易い説明が載っているのかもしれませんが、私が見つけることができたのはこの説明だけでしたので、こちらに簡単にまとめました。\n\nご参考になれば幸いです。\n","coediting":false,"created_at":"2016-04-02T09:34:00+09:00","id":"7cb06ba889f2a3dfedf3","private":false,"tags":[{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]}],"title":"SolidityのMappingについて","updated_at":"2016-04-02T09:34:00+09:00","url":"http://qiita.com/AkiTakeU/items/7cb06ba889f2a3dfedf3","user":{"description":null,"facebook_id":null,"followees_count":0,"followers_count":1,"github_login_name":"Wh1teB0x","id":"AkiTakeU","items_count":3,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":110581,"profile_image_url":"https://avatars.githubusercontent.com/u/11663186?v=3","twitter_screen_name":null,"website_url":null}},{"rendered_body":"\n<h2>\n<span id=\"step-1-コンパイラの設定ができているかの確認\" class=\"fragment\"></span><a href=\"#step-1-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E8%A8%AD%E5%AE%9A%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%81%AE%E7%A2%BA%E8%AA%8D\"><i class=\"fa fa-link\"></i></a>Step 1: コンパイラの設定ができているかの確認</h2>\n\n<p>geth consoleで</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\neth.getCompilers()\n</pre></div></div>\n\n<p>を実行すると、以下がでるはず</p>\n\n<p>['Solidity']</p>\n\n<p>上記が出たら、Step 3へ。</p>\n\n<h2>\n<span id=\"step-2-コンパイラの設定\" class=\"fragment\"></span><a href=\"#step-2-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E8%A8%AD%E5%AE%9A\"><i class=\"fa fa-link\"></i></a>Step 2: コンパイラの設定</h2>\n\n<p>apt系の場合のインストール</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nsudo add-apt-repository ppa:ethereum/ethereum\nsudo apt-get update\nsudo apt-get install solc\nwhich solc\n</pre></div></div>\n\n<p>solcのPathの設定</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nadmin.setSolc(\"path/to/solc\")\n</pre></div></div>\n\n<p>で、step 1の確認をして、['Solidity']が出力されたら、Step 3へ。</p>\n\n<h2>\n<span id=\"step-3\" class=\"fragment\"></span><a href=\"#step-3\"><i class=\"fa fa-link\"></i></a>Step 3.</h2>\n\n<p>geth consoleで以下を実行</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nsource = \"contract test { function multiply(uint a) returns(uint d) {\nreturn a * 7; } }\"\ncontract = eth.compile.solidity(source)\neth.compile.solidity(source).test\n</pre></div></div>\n\n<h2>\n<span id=\"参考\" class=\"fragment\"></span><a href=\"#%E5%8F%82%E8%80%83\"><i class=\"fa fa-link\"></i></a>参考</h2>\n\n<ul>\n<li><a href=\"https://forum.ethereum.org/discussion/3787/solc-no-build-results-error-windows\">SolC no build results error - Windows - Ethereum</a></li>\n</ul>\n\n<h2>\n<span id=\"関連用語\" class=\"fragment\"></span><a href=\"#%E9%96%A2%E9%80%A3%E7%94%A8%E8%AA%9E\"><i class=\"fa fa-link\"></i></a>関連用語</h2>\n\n<ul>\n<li>Ethereum, イーサリアム, </li>\n<li>solc, geth</li>\n<li>Windows</li>\n</ul>\n","body":"\n\n\n\n\n\n## Step 1: コンパイラの設定ができているかの確認\n\ngeth consoleで\n\n```\neth.getCompilers()\n```\n\nを実行すると、以下がでるはず\n\n['Solidity']\n\n上記が出たら、Step 3へ。\n\n\n## Step 2: コンパイラの設定\n\napt系の場合のインストール\n\n```\nsudo add-apt-repository ppa:ethereum/ethereum\nsudo apt-get update\nsudo apt-get install solc\nwhich solc\n```\n\nsolcのPathの設定\n\n```\nadmin.setSolc(\"path/to/solc\")\n```\n\n\nで、step 1の確認をして、['Solidity']が出力されたら、Step 3へ。\n\n\n## Step 3.\n\n\ngeth consoleで以下を実行\n\n```\nsource = \"contract test { function multiply(uint a) returns(uint d) {\nreturn a * 7; } }\"\ncontract = eth.compile.solidity(source)\neth.compile.solidity(source).test\n```\n\n\n## 参考\n\n* [SolC no build results error - Windows - Ethereum](https://forum.ethereum.org/discussion/3787/solc-no-build-results-error-windows)\n\n\n\n## 関連用語\n\n* Ethereum, イーサリアム, \n* solc, geth\n* Windows\n\n\n","coediting":false,"created_at":"2016-03-01T11:59:21+09:00","id":"8eaab86fd2808507f191","private":false,"tags":[{"name":"Ethereum","versions":[]}],"title":"Ethereumのsolcでビルドエラーが出た時に試すこと","updated_at":"2016-03-01T11:59:21+09:00","url":"http://qiita.com/hshimo/items/8eaab86fd2808507f191","user":{"description":"ブロックチェーン専門企業、コンセンサス・ベイス代表、志茂 博の技術メモ。\r\n興味ある方は、暗号通貨・ブロックチェーンのユーザグループへ。\r\nCryptocurrency Tech Japan\r\nhttp://crypto-tech.jp/","facebook_id":"","followees_count":6,"followers_count":208,"github_login_name":"hshimo","id":"hshimo","items_count":251,"linkedin_id":"","location":"","name":"Hiroshi Shimo","organization":"Consensus Base LLC.","permanent_id":24976,"profile_image_url":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/24976/32521deda72f5016c0b18055322400e6405a5183/medium.png?1438610616","twitter_screen_name":null,"website_url":""}},{"rendered_body":"<p>以前はMeteorとgeth, Mochaを利用して、<a href=\"http://qiita.com/azusa-kikuchi/items/8892f97235e958906de5\" id=\"reference-a61659e2cb6a6cfe4d97\">2アカウント間の送金のテスト</a>、<a href=\"http://qiita.com/azusa-kikuchi/items/89b6adbeaade021c52e5\" id=\"reference-652375020d5d64820006\">コントラクトへの送金のテスト</a>を行いました。<br>\n今回は実際にMeteorからコントラクトへ送金し、Solidityで記述したスマートコントラクトの関数を動かしてみようと思います。<br>\nMeteorの使い方は <a href=\"http://docs.meteor.com/#/full/api\">Meteorのドキュメント</a> に詳しく書かれています。</p>\n\n<h2>\n<span id=\"やりたいこと\" class=\"fragment\"></span><a href=\"#%E3%82%84%E3%82%8A%E3%81%9F%E3%81%84%E3%81%93%E3%81%A8\"><i class=\"fa fa-link\"></i></a>やりたいこと</h2>\n\n<ul>\n<li>ボタンのclickイベントを受け取り、コントラクトへ送金する</li>\n<li>トランザクションをMeteorのCollectionで管理する</li>\n<li>マイニングが完了したことを検知する</li>\n<li>スマートコントラクトの状態を確認する</li>\n</ul>\n\n<h2>\n<span id=\"気をつけること-meteorとethereumを分離する\" class=\"fragment\"></span><a href=\"#%E6%B0%97%E3%82%92%E3%81%A4%E3%81%91%E3%82%8B%E3%81%93%E3%81%A8-meteor%E3%81%A8ethereum%E3%82%92%E5%88%86%E9%9B%A2%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>気をつけること: MeteorとEthereumを分離する</h2>\n\n<p>実装に入る前に、<a href=\"https://github.com/ethereum/wiki/wiki/Dapp-using-Meteor#%C3%90app-code-structure\">Dapp using Meteor</a> に書かれていたアドバイスを確認します。</p>\n\n<blockquote>\n<ul>\n<li>put ethereum related stuff into client/lib/ethereum/somefile.js</li>\n<li>use myCollection.observe({added: func, changed: func, removed: func}) to communicate to ethereum, keep ethereum logic out of your app as much as possible. This way you just write and read from your reactive collections and the observe functions will handle the rest (e.g. sendTransactions)</li>\n<li>Filters etc will add logs etc to your collections. So you keep all the callback mess out of your app logic.</li>\n</ul>\n</blockquote>\n\n<p>Ethereumに接続する部分を、なるべくMeteorから分離することがポイントのようです。<br>\nこれを踏まえて、前回のテストコードから改善する方針を立てます。</p>\n\n<h3>\n<span id=\"前回のコードからの改善点\" class=\"fragment\"></span><a href=\"#%E5%89%8D%E5%9B%9E%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%8B%E3%82%89%E3%81%AE%E6%94%B9%E5%96%84%E7%82%B9\"><i class=\"fa fa-link\"></i></a>前回のコードからの改善点</h3>\n\n<ul>\n<li>スマートコントラクトの一連の流れを試すために複数のトランザクションを発行するので、それらをCollectionに入れて管理する</li>\n<li>トランザクション発行後、マイニングが完了したことの検知を<code>setInterval</code>ではなく<code>eth.filter</code>で行うようにする</li>\n<li>Collectionの状態監視、マイニング完了の監視を<code>client/lib/ethereum/observeTransactions.js</code>として分離する</li>\n</ul>\n\n<p>これらに気をつけながら実装を行っていきます。</p>\n\n<h2>\n<span id=\"トランザクションをmeteorのcollectionで管理する\" class=\"fragment\"></span><a href=\"#%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92meteor%E3%81%AEcollection%E3%81%A7%E7%AE%A1%E7%90%86%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>トランザクションをMeteorのCollectionで管理する</h2>\n\n<p>まずは、Blockchainへ発行したトランザクションをMongoDBで管理できるようにします。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">app/client/lib/collections.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nx\">Transactions</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Mongo</span><span class=\"p\">.</span><span class=\"nx\">Collection</span><span class=\"p\">(</span><span class=\"s1\">'transactions'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"nx\">connection</span><span class=\"o\">:</span> <span class=\"kc\">null</span><span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<h2>\n<span id=\"ボタンのclickイベントを受け取りコントラクトへ送金する\" class=\"fragment\"></span><a href=\"#%E3%83%9C%E3%82%BF%E3%83%B3%E3%81%AEclick%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%81%B8%E9%80%81%E9%87%91%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>ボタンのclickイベントを受け取り、コントラクトへ送金する</h2>\n\n<p>Meteorのtemplateにボタンを設置し、JS側でボタンのclickイベントを受け取ります。<br>\nコールバックでトランザクションを発行します。</p>\n\n<div class=\"code-frame\" data-lang=\"html\">\n<div class=\"code-lang\"><span class=\"bold\">app/client/app.html</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nt\">&lt;template</span> <span class=\"na\">name=</span><span class=\"s\">\"purchase\"</span><span class=\"nt\">&gt;</span>\n  <span class=\"nt\">&lt;button</span> <span class=\"na\">class=</span><span class=\"s\">\"purchase\"</span><span class=\"nt\">&gt;</span>出品する<span class=\"nt\">&lt;/button&gt;</span>\n<span class=\"nt\">&lt;/template&gt;</span>\n</pre></div>\n</div>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">app/client/app.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nx\">Template</span><span class=\"p\">.</span><span class=\"nx\">purchase</span><span class=\"p\">.</span><span class=\"nx\">events</span><span class=\"p\">({</span>\n  <span class=\"s1\">'click .purchase'</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">txObject</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"mi\">20</span><span class=\"p\">,</span>\n      <span class=\"nx\">gas</span><span class=\"o\">:</span> <span class=\"mi\">300000</span><span class=\"p\">,</span>\n      <span class=\"nx\">from</span><span class=\"o\">:</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">accounts</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">};</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">contractInstance</span> <span class=\"o\">=</span> <span class=\"nx\">PurchaseContract</span><span class=\"p\">.</span><span class=\"nx\">at</span><span class=\"p\">(</span><span class=\"s2\">\"contractAddress\"</span><span class=\"p\">);</span>\n    <span class=\"nx\">contractInstance</span><span class=\"p\">.</span><span class=\"nx\">Purchase</span><span class=\"p\">(</span><span class=\"kc\">null</span><span class=\"p\">,</span> <span class=\"nx\">txObject</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">result</span><span class=\"p\">){</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">err</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kd\">var</span> <span class=\"nx\">txId</span> <span class=\"o\">=</span> <span class=\"nx\">Helpers</span><span class=\"p\">.</span><span class=\"nx\">makeId</span><span class=\"p\">(</span><span class=\"s1\">'tx'</span><span class=\"p\">,</span> <span class=\"nx\">result</span><span class=\"p\">);</span>\n        <span class=\"nx\">Transactions</span><span class=\"p\">.</span><span class=\"nx\">upsert</span><span class=\"p\">(</span><span class=\"nx\">txId</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">$set</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n          <span class=\"nx\">transactionHash</span><span class=\"o\">:</span> <span class=\"nx\">result</span>\n        <span class=\"p\">}</span> <span class=\"p\">});</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">},</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<p><code>contractInstance.Purchase</code>のコールバックでCollectionを作成します。<br>\nCollectionの経過の監視のコードを、マニュアルの通り<code>client/lib/ethereum/</code>に置きます。<br>\n<code>Transaction.observe({added: func, changed: func, removed: func})</code>のように記述することで、レコードが作成・更新・削除されたことを受け取ることができます。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">client/lib/ethereum/observeTransactions.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"nx\">collectionObservers</span><span class=\"p\">[</span><span class=\"nx\">collectionObservers</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">Transactions</span><span class=\"p\">.</span><span class=\"nx\">find</span><span class=\"p\">({}).</span><span class=\"nx\">observe</span><span class=\"p\">({</span>\n  <span class=\"nx\">added</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">newDocument</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">\"added\"</span><span class=\"p\">);</span>\n    <span class=\"nx\">checkTransactionConfirmations</span><span class=\"p\">(</span><span class=\"nx\">newDocument</span><span class=\"p\">);</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">changed</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">newDocument</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">\"changed\"</span><span class=\"p\">);</span>\n    <span class=\"nx\">checkTransactionConfirmations</span><span class=\"p\">(</span><span class=\"nx\">newDocument</span><span class=\"p\">);</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">removed</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nb\">document</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">\"removed\"</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<h2>\n<span id=\"マイニングが完了したことを検知する\" class=\"fragment\"></span><a href=\"#%E3%83%9E%E3%82%A4%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%8C%E5%AE%8C%E4%BA%86%E3%81%97%E3%81%9F%E3%81%93%E3%81%A8%E3%82%92%E6%A4%9C%E7%9F%A5%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>マイニングが完了したことを検知する</h2>\n\n<p><code>web3.eth.filter(\"latest\").watch</code>を設定すると、新しいブロックが来るごとにコールバックを実行することができます。<br>\nこのコールバックの中で、該当のトランザクションのマイニングが完了しているかをチェックし、完了していた場合はウォッチを停止します。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">client/lib/ethereum/observeTransactions.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"kd\">var</span> <span class=\"nx\">filter</span> <span class=\"o\">=</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">filter</span><span class=\"p\">(</span><span class=\"s2\">\"latest\"</span><span class=\"p\">).</span><span class=\"nx\">watch</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">,</span> <span class=\"nx\">blockHash</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">getTransaction</span><span class=\"p\">(</span><span class=\"nx\">tx</span><span class=\"p\">.</span><span class=\"nx\">transactionHash</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">,</span> <span class=\"nx\">transaction</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">getTransactionReceipt</span><span class=\"p\">(</span><span class=\"nx\">tx</span><span class=\"p\">.</span><span class=\"nx\">transactionHash</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">,</span> <span class=\"nx\">receipt</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">e</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"nx\">receipt</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"nx\">transaction</span><span class=\"p\">)</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n\n    <span class=\"kd\">var</span> <span class=\"nx\">txId</span> <span class=\"o\">=</span> <span class=\"nx\">Helpers</span><span class=\"p\">.</span><span class=\"nx\">makeId</span><span class=\"p\">(</span><span class=\"s1\">'tx'</span><span class=\"p\">,</span> <span class=\"nx\">tx</span><span class=\"p\">.</span><span class=\"nx\">transactionHash</span><span class=\"p\">);</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">receipt</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// ウォレットやコントラクトの残高確認などをここで行う</span>\n        <span class=\"nx\">filter</span><span class=\"p\">.</span><span class=\"nx\">stopWatching</span><span class=\"p\">();</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">});</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<h2>\n<span id=\"スマートコントラクトの状態を確認する\" class=\"fragment\"></span><a href=\"#%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%81%AE%E7%8A%B6%E6%85%8B%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>スマートコントラクトの状態を確認する</h2>\n\n<p>スマートコントラクトを作成する際のコツのひとつに「状態を設定しておく」というのがあります。<br>\n(Youtubeに<a href=\"https://www.youtube.com/watch?v=seU7DykOxfc\">ライブコーディングの動画</a> があるのでぜひ見てみてください)</p>\n\n<p>このスマートコントラクトの例では、何度かトランザクションを発行していくことによって、スマートコントラクトの状態が変化していきます。<br>\n例えば商品が陳列された状態であれば、次のアクションは購入ができるようにする、というように、状態を検知して、その状態ごとにログをとったり、アプリの次のアクションを変えていきます。</p>\n\n<p>状態検知の方法は2種類あります。<br>\n- 状態(State)を取得<br>\n- イベントを検知</p>\n\n<p>Solidity側でのイベントおよび状態の記述はこのようになっています。</p>\n\n<div class=\"code-frame\" data-lang=\"text\">\n<div class=\"code-lang\"><span class=\"bold\">client/contracts/PurchaseContract.sol</span></div>\n<div class=\"highlight\"><pre>\nenum State { Created, Locked, Inactive }\nState public state;\nfunction Purchase()\n{\n    seller = msg.sender;\n    value = msg.value / 2;\n    if (2 * value != msg.value) throw;\n    state = State.Created;\n    created(); // イベント発行\n}\nevent created();\n</pre></div>\n</div>\n\n<h3>\n<span id=\"状態を取得する\" class=\"fragment\"></span><a href=\"#%E7%8A%B6%E6%85%8B%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>状態を取得する</h3>\n\n<p>Stateがpublicになっているので、<code>call()</code>メソッドで取得することができます。<br>\nenum型で設定していますが、戻り値はBigNumber型になっているようです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\ncontractInstance.state.call().toNumber(10) //0, 1, 2のいずれかが返ってくる\n</pre></div></div>\n\n<h3>\n<span id=\"イベントを検知する\" class=\"fragment\"></span><a href=\"#%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%82%92%E6%A4%9C%E7%9F%A5%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>イベントを検知する</h3>\n\n<p>スマートコントラクト内で発行したイベントをウォッチし、検知していきます。</p>\n\n<p>イベントのウォッチは、<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events\">Javascript APIのContract Events</a> を参考に設定しました。<br>\n今回は<code>allEvents</code>を使ってすべてのイベントをウォッチしましたが、特定のイベントのみを受けることもできるようです。</p>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">client/lib/ethereum/observeTransactions.js</span></div>\n<div class=\"highlight\"><pre>\n<span class=\"kd\">var</span> <span class=\"nx\">contractInstance</span> <span class=\"o\">=</span> <span class=\"nx\">PurchaseContract</span><span class=\"p\">.</span><span class=\"nx\">at</span><span class=\"p\">(</span><span class=\"s2\">\"contractAddress\"</span><span class=\"p\">);</span>\n<span class=\"kd\">var</span> <span class=\"nx\">events</span> <span class=\"o\">=</span> <span class=\"nx\">contractInstance</span><span class=\"p\">.</span><span class=\"nx\">allEvents</span><span class=\"p\">();</span>\n<span class=\"nx\">events</span><span class=\"p\">.</span><span class=\"nx\">watch</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">,</span> <span class=\"nx\">event</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// (今回の例では、Sessionに状態を入れて、状態ごとにボタンの出し分けをしました)</span>\n    <span class=\"nx\">Session</span><span class=\"p\">.</span><span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"s2\">\"contractState\"</span><span class=\"p\">,</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">event</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<h2>\n<span id=\"まとめ\" class=\"fragment\"></span><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"><i class=\"fa fa-link\"></i></a>まとめ</h2>\n\n<p>Meteor、MongoDBとgethを利用して、スマートコントラクトのインスタンス作成、関数の実行、状態の監視を行いました。<br>\n今回作成したコードは<a href=\"https://github.com/azusa-kikuike/learningDapp\">GitHub</a>にありますので、もしよければご覧ください。</p>\n\n<p>gethとの接続監視など、より高機能なアプリを作りたい方は、<a href=\"https://github.com/ethereum/meteor-dapp-wallet\">Meteor Dapp Wallet</a> が非常に参考なるので、そちらもご覧ください。</p>\n","body":"\n以前はMeteorとgeth, Mochaを利用して、[2アカウント間の送金のテスト](http://qiita.com/azusa-kikuchi/items/8892f97235e958906de5)、[コントラクトへの送金のテスト](http://qiita.com/azusa-kikuchi/items/89b6adbeaade021c52e5)を行いました。\n今回は実際にMeteorからコントラクトへ送金し、Solidityで記述したスマートコントラクトの関数を動かしてみようと思います。\nMeteorの使い方は [Meteorのドキュメント](http://docs.meteor.com/#/full/api) に詳しく書かれています。\n\n## やりたいこと\n\n- ボタンのclickイベントを受け取り、コントラクトへ送金する\n- トランザクションをMeteorのCollectionで管理する\n- マイニングが完了したことを検知する\n- スマートコントラクトの状態を確認する\n\n## 気をつけること: MeteorとEthereumを分離する\n\n実装に入る前に、[Dapp using Meteor](https://github.com/ethereum/wiki/wiki/Dapp-using-Meteor#%C3%90app-code-structure) に書かれていたアドバイスを確認します。\n\n>\n- put ethereum related stuff into client/lib/ethereum/somefile.js\n- use myCollection.observe({added: func, changed: func, removed: func}) to communicate to ethereum, keep ethereum logic out of your app as much as possible. This way you just write and read from your reactive collections and the observe functions will handle the rest (e.g. sendTransactions)\n- Filters etc will add logs etc to your collections. So you keep all the callback mess out of your app logic.\n\nEthereumに接続する部分を、なるべくMeteorから分離することがポイントのようです。\nこれを踏まえて、前回のテストコードから改善する方針を立てます。\n\n### 前回のコードからの改善点\n\n- スマートコントラクトの一連の流れを試すために複数のトランザクションを発行するので、それらをCollectionに入れて管理する\n- トランザクション発行後、マイニングが完了したことの検知を`setInterval`ではなく`eth.filter`で行うようにする\n- Collectionの状態監視、マイニング完了の監視を`client/lib/ethereum/observeTransactions.js`として分離する\n\nこれらに気をつけながら実装を行っていきます。\n\n## トランザクションをMeteorのCollectionで管理する\n\nまずは、Blockchainへ発行したトランザクションをMongoDBで管理できるようにします。\n\n```app/client/lib/collections.js\nTransactions = new Mongo.Collection('transactions', {connection: null});\n```\n\n## ボタンのclickイベントを受け取り、コントラクトへ送金する\n\nMeteorのtemplateにボタンを設置し、JS側でボタンのclickイベントを受け取ります。\nコールバックでトランザクションを発行します。\n\n```app/client/app.html\n<template name=\"purchase\">\n  <button class=\"purchase\">出品する</button>\n</template>\n```\n\n```app/client/app.js\nTemplate.purchase.events({\n  'click .purchase': function() {\n    var txObject = {\n      value: 20,\n      gas: 300000,\n      from: web3.eth.accounts[0]\n    };\n    var contractInstance = PurchaseContract.at(\"contractAddress\");\n    contractInstance.Purchase(null, txObject, function(err, result){\n      if (!err) {\n        var txId = Helpers.makeId('tx', result);\n        Transactions.upsert(txId, { $set: {\n          transactionHash: result\n        } });\n      }\n    });\n  },\n});\n```\n\n`contractInstance.Purchase`のコールバックでCollectionを作成します。\nCollectionの経過の監視のコードを、マニュアルの通り`client/lib/ethereum/`に置きます。\n`Transaction.observe({added: func, changed: func, removed: func})`のように記述することで、レコードが作成・更新・削除されたことを受け取ることができます。\n\n```client/lib/ethereum/observeTransactions.js\ncollectionObservers[collectionObservers.length] = Transactions.find({}).observe({\n  added: function(newDocument) {\n    console.log(\"added\");\n    checkTransactionConfirmations(newDocument);\n  },\n  changed: function(newDocument) {\n    console.log(\"changed\");\n    checkTransactionConfirmations(newDocument);\n  },\n  removed: function(document) {\n    console.log(\"removed\");\n  }\n});\n```\n\n## マイニングが完了したことを検知する\n\n`web3.eth.filter(\"latest\").watch`を設定すると、新しいブロックが来るごとにコールバックを実行することができます。\nこのコールバックの中で、該当のトランザクションのマイニングが完了しているかをチェックし、完了していた場合はウォッチを停止します。\n\n```client/lib/ethereum/observeTransactions.js\nvar filter = web3.eth.filter(\"latest\").watch(function(e, blockHash) {\n  web3.eth.getTransaction(tx.transactionHash, function(e, transaction) {\n    web3.eth.getTransactionReceipt(tx.transactionHash, function(e, receipt) {\n      if (e || !receipt || !transaction) return;\n\n    var txId = Helpers.makeId('tx', tx.transactionHash);\n      if (receipt) {\n        // ウォレットやコントラクトの残高確認などをここで行う\n        filter.stopWatching();\n      }\n    });\n  });\n});\n```\n\n## スマートコントラクトの状態を確認する\n\nスマートコントラクトを作成する際のコツのひとつに「状態を設定しておく」というのがあります。\n(Youtubeに[ライブコーディングの動画](https://www.youtube.com/watch?v=seU7DykOxfc) があるのでぜひ見てみてください)\n\nこのスマートコントラクトの例では、何度かトランザクションを発行していくことによって、スマートコントラクトの状態が変化していきます。\n例えば商品が陳列された状態であれば、次のアクションは購入ができるようにする、というように、状態を検知して、その状態ごとにログをとったり、アプリの次のアクションを変えていきます。\n\n状態検知の方法は2種類あります。\n- 状態(State)を取得\n- イベントを検知\n\nSolidity側でのイベントおよび状態の記述はこのようになっています。\n\n```client/contracts/PurchaseContract.sol\nenum State { Created, Locked, Inactive }\nState public state;\nfunction Purchase()\n{\n    seller = msg.sender;\n    value = msg.value / 2;\n    if (2 * value != msg.value) throw;\n    state = State.Created;\n    created(); // イベント発行\n}\nevent created();\n```\n\n### 状態を取得する\n\nStateがpublicになっているので、`call()`メソッドで取得することができます。\nenum型で設定していますが、戻り値はBigNumber型になっているようです。\n\n```\ncontractInstance.state.call().toNumber(10) //0, 1, 2のいずれかが返ってくる\n```\n\n### イベントを検知する\n\nスマートコントラクト内で発行したイベントをウォッチし、検知していきます。\n\nイベントのウォッチは、[Javascript APIのContract Events](https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events) を参考に設定しました。\n今回は`allEvents`を使ってすべてのイベントをウォッチしましたが、特定のイベントのみを受けることもできるようです。\n\n```client/lib/ethereum/observeTransactions.js\nvar contractInstance = PurchaseContract.at(\"contractAddress\");\nvar events = contractInstance.allEvents();\nevents.watch(function(error, event) {\n  if (!error) {\n    // (今回の例では、Sessionに状態を入れて、状態ごとにボタンの出し分けをしました)\n    Session.set(\"contractState\", event.event);\n  }\n});\n```\n\n## まとめ\n\nMeteor、MongoDBとgethを利用して、スマートコントラクトのインスタンス作成、関数の実行、状態の監視を行いました。\n今回作成したコードは[GitHub](https://github.com/azusa-kikuike/learningDapp)にありますので、もしよければご覧ください。\n\ngethとの接続監視など、より高機能なアプリを作りたい方は、[Meteor Dapp Wallet](https://github.com/ethereum/meteor-dapp-wallet) が非常に参考なるので、そちらもご覧ください。\n","coediting":false,"created_at":"2016-02-19T09:55:22+09:00","id":"405154b3619ca30ed14c","private":false,"tags":[{"name":"Meteor","versions":[]},{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]}],"title":"geth, Meteor上で簡単なアプリ(Dapp)を作成する","updated_at":"2016-02-19T09:55:22+09:00","url":"http://qiita.com/azusa-kikuchi/items/405154b3619ca30ed14c","user":{"description":null,"facebook_id":null,"followees_count":8,"followers_count":14,"github_login_name":"azusa-kikuike","id":"azusa-kikuchi","items_count":5,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":64932,"profile_image_url":"https://secure.gravatar.com/avatar/bae8b2f739ca8e8aa51ca54d3fba93dc","twitter_screen_name":null,"website_url":null}},{"rendered_body":"<p><a href=\"http://qiita.com/azusa-kikuchi/items/8892f97235e958906de5\" id=\"reference-f05584dfc6516cb2dec8\">以前の投稿</a> では、go-ethereumとMeteorを使って、2つのアカウント間の送金をテストしてみました。<br>\n今回は、Meteor上でEthereumのスマートコントラクトを作成し、そのスマートコントラクトに対して送金のテストを行います。</p>\n\n<p>gethの起動オプション、アカウントの追加などについては、以前の投稿をご覧ください。</p>\n\n<h2>\n<span id=\"やりたいこと\" class=\"fragment\"></span><a href=\"#%E3%82%84%E3%82%8A%E3%81%9F%E3%81%84%E3%81%93%E3%81%A8\"><i class=\"fa fa-link\"></i></a>やりたいこと</h2>\n\n<ul>\n<li>スマートコントラクトを書く</li>\n<li>スマートコントラクトアカウントを作成する</li>\n<li>スマートコントラクトへ送金し、関数を実行する</li>\n</ul>\n\n<h2>\n<span id=\"スマートコントラクトを書く\" class=\"fragment\"></span><a href=\"#%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%82%92%E6%9B%B8%E3%81%8F\"><i class=\"fa fa-link\"></i></a>スマートコントラクトを書く</h2>\n\n<p>Ethereumでは、Solidity, Serpent, LLLなどの言語を使ってスマートコントラクトを記述することができます。<br>\nSolidityは、JavaScriptに書き方が似ている言語とされ、<a href=\"https://solidity.readthedocs.org/en/latest/index.html\">ドキュメント</a>も充実しています。<br>\n今回は、スマートコントラクトのサンプルとして、Solidity Tutorialの<a href=\"https://solidity.readthedocs.org/en/latest/solidity-by-example.html#safe-remote-purchase\">Safe Remote Purchase</a> に書かれているPurchase Contractを試しました。</p>\n\n<p>Purchase Contractでは、売り手と買い手の間に入る信頼できる中間機関が存在しない中で、売り手と買い手が最初にデポジットすることで安全に取引を行う、という方法を採用しています。詳しくは、Oleg Andreevさんの<a href=\"http://blog.oleganza.com/post/58240549599/contracts-without-trust-or-third-parties\">Contracts without trust or third parties</a> の記事が参考になります。</p>\n\n<p>記述したスマートコントラクトは、<code>PurchaseContract.sol</code>というファイル名で保存します。ディレクトリ構造は以下のように配置しました。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n.\n├── README.md\n├── app\n│   ├── client\n│   │   ├── contracts\n│   │   │   ├── MultiplyContract.sol\n│   │   │   └── PurchaseContract.sol\n│   │   ├── learningDapp.html\n│   │   ├── learningDapp.js\n│   │   ├── learningDapp.less\n│   │   └── lib\n│   │       └── init.js\n│   └── tests\n│       └── mocha\n│           └── client\n│               ├── MultiplyContract.js\n│               ├── PurchaseContract.js\n│               └── Transaction.js\n├── config\n│   └── genesis\n│       └── dev_genesis.json\n├── console.sh\n├── geth.sh\n└── initialize.js\n</pre></div></div>\n\n<p>Meteorのファイルの読み込み順序に気をつけてください。コントラクトの定義のほうがコントラクトの利用より先になるように、ディレクトリ構成やファイル名を調整して設置することがポイントです。</p>\n\n<h3>\n<span id=\"スマートコントラクトをコンパイルするライブラリを入れる\" class=\"fragment\"></span><a href=\"#%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%82%92%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%99%E3%82%8B%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%82%92%E5%85%A5%E3%82%8C%E3%82%8B\"><i class=\"fa fa-link\"></i></a>スマートコントラクトをコンパイルするライブラリを入れる</h3>\n\n<p>SolidityをJavaScriptから使えるようにするために、Meteorにライブラリを入れます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nmeteor add silentcicero:solc\n</pre></div></div>\n\n<p><code>solc</code>ライブラリを入れると、<code>.sol</code>と名前がついたSolidityファイルを読み込んでJavaScriptから使える形にコンパイルしてくれます。</p>\n\n<p>solcを使わない場合は、gethコンソールなどを利用して自力でコンパイルしておく方法もあります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\n&gt; contract = eth.compile.solidity(source).test\n&gt; MyContract = eth.contract(abi);\n</pre></div></div>\n\n<h2>\n<span id=\"スマートコントラクトアカウントを作成する\" class=\"fragment\"></span><a href=\"#%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>スマートコントラクトアカウントを作成する</h2>\n\n<p>スマートコントラクトが記述できたら、スマートコントラクトのインスタンスを作ります。<br>\nEthereumでは、スマートコントラクトは1つのアカウントとして設計されているので、インスタンスを作る際は、普通のアカウントにトランザクションを行うようにコントラクトにトランザクションを送ります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nPurchaseContract.new(transactionObject, function(err, contract){\n  chai.assert.isNull(err);\n  if (!err) {\n    if (!contract.address) {\n      console.log(\"txHash: \" + contract.transactionHash);\n    } else {\n      console.log(\"address: \" + contract.address);\n      contractInstance = contract;\n      done();\n    }\n  }\n});\n</pre></div></div>\n\n<p>このnewのコールバックは <em>2回呼ばれる</em> ことに注意が必要です。</p>\n\n<p>1回目はトランザクションを発行した瞬間に呼ばれ、contractオブジェクトには<code>transactionHash</code>が入ります。<br>\n2回目はマイニング完了後に呼ばれ、contractオブジェクトに<code>address</code>が追加されます。このコントラクトのインスタンスを後ほど利用します。</p>\n\n<h2>\n<span id=\"スマートコントラクトへ送金し関数を実行する\" class=\"fragment\"></span><a href=\"#%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%81%B8%E9%80%81%E9%87%91%E3%81%97%E9%96%A2%E6%95%B0%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>スマートコントラクトへ送金し、関数を実行する</h2>\n\n<p>スマートコントラクトアカウントが作成できたので、関数を実行するためにスマートコントラクトへ送金します。</p>\n\n<p>関数を実行する方法には、<code>call</code>とTransactionの2つが存在します。</p>\n\n<p><code>call</code>は読み込み専用のメソッドで、関数を実行するものの、Blockchainへ流すことはありません。従って、マイニングもされず、Etherも消費しません。<br>\n反対に、<code>contractInstance.{Method名}</code>でTransactionを発行した内容は、Blockchainに送られ、マイニングされます。Blockchainやアカウントの状態も変更する書き込みのメソッドです。<br>\nTransactionはEtherを消費するので、最初に<code>call</code>で試した後にTransactionを使うことが奨められています。</p>\n\n<p>では実際にスマートコントラクトを実行してみます。<br>\n<code>Purchase</code>メソッドに対してTransactionを送り、マイニングされたことを<code>getTransactionReceipt</code>で確認します。<br>\nマイニング後、コントラクトで定義した売り手、値が合致していることをMochaを使って確認しています。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>\nvar txObject = {\n  value: 20,\n  gas: 300000,\n  from: web3.eth.accounts[0]\n};\nit(\"should purchase\", function(done) {\n  this.timeout(timeout);\n  contractInstance.Purchase(null, txObject, function(err, result) {\n    if (!err) {\n      var timer;\n      clearInterval(timer);\n      timer = setInterval(function(){\n        var receipt = web3.eth.getTransactionReceipt(result);\n        if (receipt) {\n          clearInterval(timer);\n          chai.assert.equal(contractInstance.seller(), web3.eth.accounts[0], \"seller == sender\");\n          chai.assert.equal(contractInstance.value().toNumber(10), 10, \"value == sendValue / 2\");\n          console.log(contractInstance.seller());\n          console.log(contractInstance.value().toNumber(10));\n          done();\n        }\n      }, 1000);\n    }\n  });\n});\n</pre></div></div>\n\n<h2>\n<span id=\"おわりに\" class=\"fragment\"></span><a href=\"#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB\"><i class=\"fa fa-link\"></i></a>おわりに</h2>\n\n<p>今回作成したコードは、<a href=\"https://github.com/azusa-kikuike/learningDapp\">GitHub</a>から見ていただくことができます。</p>\n\n<h2>\n<span id=\"参考\" class=\"fragment\"></span><a href=\"#%E5%8F%82%E8%80%83\"><i class=\"fa fa-link\"></i></a>参考</h2>\n\n<ul>\n<li><a href=\"http://qiita.com/n-oshiro/items/be9be5639e09e2b80902\" id=\"reference-9c92314ba08a6d1c2ca7\">Meteor 開発者がおさえておきたい「ファイルの読み込み順番(File Load Order)」</a></li>\n<li><a href=\"http://ethereum.stackexchange.com/questions/765/what-is-the-difference-between-a-transaction-and-a-call\">What is the difference between a transaction and a call?</a></li>\n</ul>\n","body":"\n[以前の投稿](http://qiita.com/azusa-kikuchi/items/8892f97235e958906de5) では、go-ethereumとMeteorを使って、2つのアカウント間の送金をテストしてみました。\n今回は、Meteor上でEthereumのスマートコントラクトを作成し、そのスマートコントラクトに対して送金のテストを行います。\n\ngethの起動オプション、アカウントの追加などについては、以前の投稿をご覧ください。\n\n## やりたいこと\n\n- スマートコントラクトを書く\n- スマートコントラクトアカウントを作成する\n- スマートコントラクトへ送金し、関数を実行する\n\n## スマートコントラクトを書く\n\nEthereumでは、Solidity, Serpent, LLLなどの言語を使ってスマートコントラクトを記述することができます。\nSolidityは、JavaScriptに書き方が似ている言語とされ、[ドキュメント](https://solidity.readthedocs.org/en/latest/index.html)も充実しています。\n今回は、スマートコントラクトのサンプルとして、Solidity Tutorialの[Safe Remote Purchase](https://solidity.readthedocs.org/en/latest/solidity-by-example.html#safe-remote-purchase) に書かれているPurchase Contractを試しました。\n\nPurchase Contractでは、売り手と買い手の間に入る信頼できる中間機関が存在しない中で、売り手と買い手が最初にデポジットすることで安全に取引を行う、という方法を採用しています。詳しくは、Oleg Andreevさんの[Contracts without trust or third parties](http://blog.oleganza.com/post/58240549599/contracts-without-trust-or-third-parties) の記事が参考になります。\n\n記述したスマートコントラクトは、`PurchaseContract.sol`というファイル名で保存します。ディレクトリ構造は以下のように配置しました。\n\n```\n.\n├── README.md\n├── app\n│   ├── client\n│   │   ├── contracts\n│   │   │   ├── MultiplyContract.sol\n│   │   │   └── PurchaseContract.sol\n│   │   ├── learningDapp.html\n│   │   ├── learningDapp.js\n│   │   ├── learningDapp.less\n│   │   └── lib\n│   │       └── init.js\n│   └── tests\n│       └── mocha\n│           └── client\n│               ├── MultiplyContract.js\n│               ├── PurchaseContract.js\n│               └── Transaction.js\n├── config\n│   └── genesis\n│       └── dev_genesis.json\n├── console.sh\n├── geth.sh\n└── initialize.js\n```\n\nMeteorのファイルの読み込み順序に気をつけてください。コントラクトの定義のほうがコントラクトの利用より先になるように、ディレクトリ構成やファイル名を調整して設置することがポイントです。\n\n### スマートコントラクトをコンパイルするライブラリを入れる\n\nSolidityをJavaScriptから使えるようにするために、Meteorにライブラリを入れます。\n\n```\nmeteor add silentcicero:solc\n```\n\n`solc`ライブラリを入れると、`.sol`と名前がついたSolidityファイルを読み込んでJavaScriptから使える形にコンパイルしてくれます。\n\nsolcを使わない場合は、gethコンソールなどを利用して自力でコンパイルしておく方法もあります。\n\n```\n> contract = eth.compile.solidity(source).test\n> MyContract = eth.contract(abi);\n```\n\n## スマートコントラクトアカウントを作成する\n\nスマートコントラクトが記述できたら、スマートコントラクトのインスタンスを作ります。\nEthereumでは、スマートコントラクトは1つのアカウントとして設計されているので、インスタンスを作る際は、普通のアカウントにトランザクションを行うようにコントラクトにトランザクションを送ります。\n\n```\nPurchaseContract.new(transactionObject, function(err, contract){\n  chai.assert.isNull(err);\n  if (!err) {\n    if (!contract.address) {\n      console.log(\"txHash: \" + contract.transactionHash);\n    } else {\n      console.log(\"address: \" + contract.address);\n      contractInstance = contract;\n      done();\n    }\n  }\n});\n```\n\nこのnewのコールバックは *2回呼ばれる* ことに注意が必要です。\n\n1回目はトランザクションを発行した瞬間に呼ばれ、contractオブジェクトには`transactionHash`が入ります。\n2回目はマイニング完了後に呼ばれ、contractオブジェクトに`address`が追加されます。このコントラクトのインスタンスを後ほど利用します。\n\n## スマートコントラクトへ送金し、関数を実行する\n\nスマートコントラクトアカウントが作成できたので、関数を実行するためにスマートコントラクトへ送金します。\n\n関数を実行する方法には、`call`とTransactionの2つが存在します。\n\n`call`は読み込み専用のメソッドで、関数を実行するものの、Blockchainへ流すことはありません。従って、マイニングもされず、Etherも消費しません。\n反対に、`contractInstance.{Method名}`でTransactionを発行した内容は、Blockchainに送られ、マイニングされます。Blockchainやアカウントの状態も変更する書き込みのメソッドです。\nTransactionはEtherを消費するので、最初に`call`で試した後にTransactionを使うことが奨められています。\n\nでは実際にスマートコントラクトを実行してみます。\n`Purchase`メソッドに対してTransactionを送り、マイニングされたことを`getTransactionReceipt`で確認します。\nマイニング後、コントラクトで定義した売り手、値が合致していることをMochaを使って確認しています。\n\n```\nvar txObject = {\n  value: 20,\n  gas: 300000,\n  from: web3.eth.accounts[0]\n};\nit(\"should purchase\", function(done) {\n  this.timeout(timeout);\n  contractInstance.Purchase(null, txObject, function(err, result) {\n    if (!err) {\n      var timer;\n      clearInterval(timer);\n      timer = setInterval(function(){\n        var receipt = web3.eth.getTransactionReceipt(result);\n        if (receipt) {\n          clearInterval(timer);\n          chai.assert.equal(contractInstance.seller(), web3.eth.accounts[0], \"seller == sender\");\n          chai.assert.equal(contractInstance.value().toNumber(10), 10, \"value == sendValue / 2\");\n          console.log(contractInstance.seller());\n          console.log(contractInstance.value().toNumber(10));\n          done();\n        }\n      }, 1000);\n    }\n  });\n});\n```\n\n## おわりに\n\n今回作成したコードは、[GitHub](https://github.com/azusa-kikuike/learningDapp)から見ていただくことができます。\n\n## 参考\n\n- [Meteor 開発者がおさえておきたい「ファイルの読み込み順番(File Load Order)」](http://qiita.com/n-oshiro/items/be9be5639e09e2b80902)\n- [What is the difference between a transaction and a call?](http://ethereum.stackexchange.com/questions/765/what-is-the-difference-between-a-transaction-and-a-call)\n","coediting":false,"created_at":"2016-02-08T15:42:10+09:00","id":"89b6adbeaade021c52e5","private":false,"tags":[{"name":"Meteor","versions":[]},{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]}],"title":"geth, Meteor上でコントラクトへの送金テストを行う","updated_at":"2016-02-08T15:42:10+09:00","url":"http://qiita.com/azusa-kikuchi/items/89b6adbeaade021c52e5","user":{"description":null,"facebook_id":null,"followees_count":8,"followers_count":14,"github_login_name":"azusa-kikuike","id":"azusa-kikuchi","items_count":5,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":64932,"profile_image_url":"https://secure.gravatar.com/avatar/bae8b2f739ca8e8aa51ca54d3fba93dc","twitter_screen_name":null,"website_url":null}},{"rendered_body":"<p>今回はSolidityのコードを書いてメソッドを実行、そして実行の監視をしてみます。</p>\n\n<ul>\n<li><p>Solidityの詳細解説ページ<br>\n<a href=\"http://solidity.readthedocs.org/en/latest/contracts.html#events\" class=\"autolink\">http://solidity.readthedocs.org/en/latest/contracts.html#events</a></p></li>\n<li><p>Ethereum JavaScript API document(eventメソッド）<br>\n<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events\" class=\"autolink\">https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events</a></p></li>\n</ul>\n\n<p>試すコントラクトはこちら↓</p>\n\n<div class=\"code-frame\" data-lang=\"text\">\n<div class=\"code-lang\"><span class=\"bold\">SimpleStorage.sol</span></div>\n<div class=\"highlight\"><pre>contract SimpleStorage {\n    bytes32 storedData;\n    //イベント設置\n    event Set(address from,bytes32 stored);\n\n    function set(bytes32 x) {\n        storedData = x;\n\n        //イベント発火\n        Set(msg.sender,x);\n    }\n    function get() constant returns (bytes32 retVal) {\n        return storedData;\n    }\n}    \n</pre></div>\n</div>\n\n<h3>\n<span id=\"イベント定義部分\" class=\"fragment\"></span><a href=\"#%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E5%AE%9A%E7%BE%A9%E9%83%A8%E5%88%86\"><i class=\"fa fa-link\"></i></a>イベント定義部分</h3>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre> event Set(address from,bytes32 stored);\n</pre></div></div>\n\n<p>setメソッドに付随するイベントを定義</p>\n\n<p>引数は任意の変数。ここに書いた変数の値がイベント発火時に渡される</p>\n\n<h3>\n<span id=\"イベント発火部分\" class=\"fragment\"></span><a href=\"#%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E7%99%BA%E7%81%AB%E9%83%A8%E5%88%86\"><i class=\"fa fa-link\"></i></a>イベント発火部分</h3>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>    function set(bytes32 x) {\n        storedData = x;\n\n        //イベント発火\n        Set(msg.sender,x);\n    }\n</pre></div></div>\n\n<p>ここではSet()に値を渡す。第１引数msg.senderはメソッド呼び出し元のアドレス,xは与えた値</p>\n\n<h1>\n<span id=\"イベント監視\" class=\"fragment\"></span><a href=\"#%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E7%9B%A3%E8%A6%96\"><i class=\"fa fa-link\"></i></a>イベント監視</h1>\n\n<div class=\"code-frame\" data-lang=\"javascript\">\n<div class=\"code-lang\"><span class=\"bold\">event-watch.js</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">var</span> <span class=\"nx\">Web3</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">'web3'</span><span class=\"p\">);</span>\n<span class=\"kd\">var</span> <span class=\"nx\">web3</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Web3</span><span class=\"p\">();</span>\n\n<span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">setProvider</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">providers</span><span class=\"p\">.</span><span class=\"nx\">HttpProvider</span><span class=\"p\">(</span><span class=\"s2\">\"http://localhost:8545\"</span><span class=\"p\">);</span>\n\n<span class=\"c1\">//simplestorageのABI</span>\n<span class=\"kd\">var</span> <span class=\"nx\">ABI</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">'./simplestorage.json'</span><span class=\"p\">);</span>\n\n<span class=\"c1\">//デプロイしたアドレス</span>\n<span class=\"kd\">var</span> <span class=\"nx\">address</span> <span class=\"o\">=</span> <span class=\"s1\">'0xf9f0ce2e38fbe115d2500606ebd7750f8876c8cc</span>\n<span class=\"s1\">'</span><span class=\"p\">;</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">simpleStorage</span> <span class=\"o\">=</span> <span class=\"nx\">web3</span><span class=\"p\">.</span><span class=\"nx\">eth</span><span class=\"p\">.</span><span class=\"nx\">contract</span><span class=\"p\">(</span><span class=\"nx\">ABI</span><span class=\"p\">).</span><span class=\"nx\">at</span><span class=\"p\">(</span><span class=\"nx\">address</span><span class=\"p\">);</span>\n<span class=\"kd\">var</span> <span class=\"nx\">event</span> <span class=\"o\">=</span> <span class=\"nx\">simpleStorage</span><span class=\"p\">.</span><span class=\"nx\">Set</span><span class=\"p\">();</span>\n<span class=\"c1\">//イベント監視</span>\n<span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">watch</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">,</span> <span class=\"nx\">result</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">'watching \"Set\" event!'</span><span class=\"p\">);</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">error</span><span class=\"p\">)</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n</pre></div>\n</div>\n\n<h2>\n<span id=\"cosmo-editorを使用したデプロイ\" class=\"fragment\"></span><a href=\"#cosmo-editor%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4\"><i class=\"fa fa-link\"></i></a><a href=\"http://meteor-dapp-cosmo.meteor.com/\">cosmo editor</a>を使用したデプロイ</h2>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/80546/f75d133b-b3d8-c9c9-082e-b298ddfd6cf5.png\" target=\"_blank\"><img src=\"https://qiita-image-store.s3.amazonaws.com/0/80546/f75d133b-b3d8-c9c9-082e-b298ddfd6cf5.png\" alt=\"160103-0001.png\" title=\"160103-0001.png\"></a></p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>//ローカルのコマンドラインでイベント監視スクリプト実行\nnode event-watch.js\n</pre></div></div>\n\n<h2>\n<span id=\"cosmoからsetメソッドで値をセットする\" class=\"fragment\"></span><a href=\"#cosmo%E3%81%8B%E3%82%89set%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A7%E5%80%A4%E3%82%92%E3%82%BB%E3%83%83%E3%83%88%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>cosmoからsetメソッドで値をセットする。</h2>\n\n<p>\"hello eth!\"をsetする。(transactionの送信）</p>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/80546/b2715290-95fa-a317-ad7b-42e78d06438c.png\" target=\"_blank\"><img src=\"https://qiita-image-store.s3.amazonaws.com/0/80546/b2715290-95fa-a317-ad7b-42e78d06438c.png\" alt=\"160103-0003.png\" title=\"160103-0003.png\"></a></p>\n\n<h2>\n<span id=\"数十秒待つとターミナルでsetイベントが表示された\" class=\"fragment\"></span><a href=\"#%E6%95%B0%E5%8D%81%E7%A7%92%E5%BE%85%E3%81%A4%E3%81%A8%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB%E3%81%A7set%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%81%8C%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%9F\"><i class=\"fa fa-link\"></i></a>数十秒待つとターミナルでSetイベントが表示された！！</h2>\n\n<p><a href=\"https://qiita-image-store.s3.amazonaws.com/0/80546/86d82321-d0ed-f527-839d-55b7f7ddee15.png\" target=\"_blank\"><img src=\"https://qiita-image-store.s3.amazonaws.com/0/80546/86d82321-d0ed-f527-839d-55b7f7ddee15.png\" alt=\"160103-0004.png\" title=\"160103-0004.png\"></a></p>\n\n<p>argsの中身が送信内容<br>\nfromが送信元アドレス ,storedが変数に保存した値。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>args: \n   { from: '0x2a595f16eee4cb0c17d9a2d939b3c10f6c677243',\n     stored: '0x68656c6c6f206574682100000000000000000000000000000000000000000000' }\n</pre></div></div>\n\n<p>このままだと16進数なので、ASCIIコードに変換してみると・・・・<br>\n<a href=\"https://qiita-image-store.s3.amazonaws.com/0/80546/ad556c66-da0c-e805-52a0-654a2013ac8c.png\" target=\"_blank\"><img src=\"https://qiita-image-store.s3.amazonaws.com/0/80546/ad556c66-da0c-e805-52a0-654a2013ac8c.png\" alt=\"160103-0006.png\" title=\"160103-0006.png\"></a></p>\n\n<p>\"hello eth!\"と表示されました。</p>\n\n<p>トランザクションはこちらでも確認できます<br>\n<a href=\"https://www.etherchain.org/account/0xf9f0ce2e38fbe115d2500606ebd7750f8876c8cc#txreceived\" class=\"autolink\">https://www.etherchain.org/account/0xf9f0ce2e38fbe115d2500606ebd7750f8876c8cc#txreceived</a></p>\n\n<p>以上がコントラクトのイベント監視の流れです。他にもAPIにはfilterなどのメソッドで同様の機能があるようです。</p>\n","body":"\n今回はSolidityのコードを書いてメソッドを実行、そして実行の監視をしてみます。\n\n* Solidityの詳細解説ページ\nhttp://solidity.readthedocs.org/en/latest/contracts.html#events\n\n* Ethereum JavaScript API document(eventメソッド）\nhttps://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events\n\n試すコントラクトはこちら↓\n\n```SimpleStorage.sol\ncontract SimpleStorage {\n    bytes32 storedData;\n    //イベント設置\n    event Set(address from,bytes32 stored);\n\n    function set(bytes32 x) {\n        storedData = x;\n        \n        //イベント発火\n        Set(msg.sender,x);\n    }\n    function get() constant returns (bytes32 retVal) {\n        return storedData;\n    }\n}    \n\n```\n\n###イベント定義部分\n```\n event Set(address from,bytes32 stored);\n```\n\nsetメソッドに付随するイベントを定義\n\n引数は任意の変数。ここに書いた変数の値がイベント発火時に渡される\n\n###イベント発火部分\n\n```\n    function set(bytes32 x) {\n        storedData = x;\n        \n        //イベント発火\n        Set(msg.sender,x);\n    }\n```\nここではSet()に値を渡す。第１引数msg.senderはメソッド呼び出し元のアドレス,xは与えた値\n\n\n#イベント監視\n```event-watch.js\nvar Web3 = require('web3');\nvar web3 = new Web3();\n\nweb3.setProvider(new web3.providers.HttpProvider(\"http://localhost:8545\");\n\n//simplestorageのABI\nvar ABI = require('./simplestorage.json');\n\n//デプロイしたアドレス\nvar address = '0xf9f0ce2e38fbe115d2500606ebd7750f8876c8cc\n';\n\nvar simpleStorage = web3.eth.contract(ABI).at(address);\nvar event = simpleStorage.Set();\n//イベント監視\nevent.watch(function (error, result) {\n console.log('watching \"Set\" event!');\n  if (!error)\n    console.log(result);\n});\n\n```\n\n##[cosmo editor](http://meteor-dapp-cosmo.meteor.com/)を使用したデプロイ\n![160103-0001.png](https://qiita-image-store.s3.amazonaws.com/0/80546/f75d133b-b3d8-c9c9-082e-b298ddfd6cf5.png \"160103-0001.png\")\n\n```\n//ローカルのコマンドラインでイベント監視スクリプト実行\nnode event-watch.js\n```\n\n\n##cosmoからsetメソッドで値をセットする。\n\"hello eth!\"をsetする。(transactionの送信）\n\n![160103-0003.png](https://qiita-image-store.s3.amazonaws.com/0/80546/b2715290-95fa-a317-ad7b-42e78d06438c.png \"160103-0003.png\")\n\n\n\n##数十秒待つとターミナルでSetイベントが表示された！！\n\n![160103-0004.png](https://qiita-image-store.s3.amazonaws.com/0/80546/86d82321-d0ed-f527-839d-55b7f7ddee15.png \"160103-0004.png\")\n\nargsの中身が送信内容\nfromが送信元アドレス ,storedが変数に保存した値。\n\n```\nargs: \n   { from: '0x2a595f16eee4cb0c17d9a2d939b3c10f6c677243',\n     stored: '0x68656c6c6f206574682100000000000000000000000000000000000000000000' }\n```\n\nこのままだと16進数なので、ASCIIコードに変換してみると・・・・\n![160103-0006.png](https://qiita-image-store.s3.amazonaws.com/0/80546/ad556c66-da0c-e805-52a0-654a2013ac8c.png \"160103-0006.png\")\n\n\n\"hello eth!\"と表示されました。\n\nトランザクションはこちらでも確認できます\nhttps://www.etherchain.org/account/0xf9f0ce2e38fbe115d2500606ebd7750f8876c8cc#txreceived\n\n\n以上がコントラクトのイベント監視の流れです。他にもAPIにはfilterなどのメソッドで同様の機能があるようです。\n\n\n\n","coediting":false,"created_at":"2016-01-03T21:39:38+09:00","id":"d9c2dabfbf513e44f78b","private":false,"tags":[{"name":"Bitcoin","versions":[]},{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]},{"name":"ブロックチェーン","versions":[]}],"title":"Ethereumでコントラクトの監視 - Event -","updated_at":"2016-01-04T00:31:19+09:00","url":"http://qiita.com/satons/items/d9c2dabfbf513e44f78b","user":{"description":null,"facebook_id":null,"followees_count":2,"followers_count":7,"github_login_name":"starcharles","id":"satons","items_count":11,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":80546,"profile_image_url":"https://avatars.githubusercontent.com/u/7988311?v=3","twitter_screen_name":null,"website_url":null}},{"rendered_body":"<p>Contract info (metadata)</p>\n\n<p>参考<br>\n<a href=\"https://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions\" class=\"autolink\">https://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions</a></p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>source = \"contract test {\n   /// @notice Will multiply `a` by 7.\n   function multiply(uint a) returns(uint d) {\n       return a * 7;\n   }\n}\"\ncontract = eth.compile.solidity(source).test\nMyContract = eth.contract(contract.info.abiDefinition)\ncontenthash = admin.saveInfo(contract.info, \"~/dapps/shared/contracts/test/info.json\")\nMyContract.new({from: primary, data: contract.code}, function(error, contract){\n  if(!error &amp;&amp; contract.address) {\n    admin.register(primary, contract.address, contenthash)\n    // put it up on your favourite oldworld site:\n    admin.registerUrl(contentHash, \"http://dapphub.com/test/info.json\")\n  }\n});\n</pre></div></div>\n\n<ul>\n<li><p>contentHash<br>\nデプロイしたContractの情報(mete data)を含むinfo.jsonファイルのハッシュ値。<br>\n　これを登録する(admin.reister)</p></li>\n<li>\n<p>contentUrlを登録する</p>\n\n<ul>\n<li>Urlは他の人が見れるサイト。info.jsonをアップロードしておく。</li>\n<li>admin.registerUrlでそのUrlを登録する</li>\n</ul>\n</li>\n</ul>\n\n<p>疑問</p>\n\n<ul>\n<li>なぜわざわざ情報を登録するのか？jsonをアップロードとかめんどくさいしdecentralizedと言えない。ブロックチェーンで完結しないのか？</li>\n</ul>\n\n<p>参考サイト（上記）にこのような文言があった。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>Note that if we use content addressed storage system like swarm the second step is unnecessary, since the contenthash is (deterministically translates to) the unique address of the content itself.\n</pre></div></div>\n\n<p>つまり、Swarmなどの分散データベースが実装されれば、contractにきちんと一意性のあるcontentHash値が得られるようになるが、いまはまだ実装できていないので、それまでは一意性が保てない。なので、どこかにmeta dataをアップロードしておかないと、そのcontractが信頼できるかわからない。metadataからハッシュ計算でcontentHashが得られるので、それと一致すれば良い。<br>\n　なのでcontentUrlは単にファイルが見れる場所であればどこでもよい（はず）</p>\n\n<h2>\n<span id=\"create-and-deploy-globalregistrar-hashreg-and-urlhint\" class=\"fragment\"></span><a href=\"#create-and-deploy-globalregistrar-hashreg-and-urlhint\"><i class=\"fa fa-link\"></i></a>Create and deploy GlobalRegistrar, HashReg and UrlHint</h2>\n\n<p>きちんとデプロイするための方法が書いてある？（未読）</p>\n\n<h4>\n<span id=\"adminsetglobalregistrar\" class=\"fragment\"></span><a href=\"#adminsetglobalregistrar\"><i class=\"fa fa-link\"></i></a>admin.setGlobalRegistrar();</h4>\n\n<p>実装されてないとの書き込みが１０月の段階であったので今使えるか不明。以降の課題。</p>\n","body":"\nContract info (metadata)\n\n参考\nhttps://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions\n\n```\nsource = \"contract test {\n   /// @notice Will multiply `a` by 7.\n   function multiply(uint a) returns(uint d) {\n       return a * 7;\n   }\n}\"\ncontract = eth.compile.solidity(source).test\nMyContract = eth.contract(contract.info.abiDefinition)\ncontenthash = admin.saveInfo(contract.info, \"~/dapps/shared/contracts/test/info.json\")\nMyContract.new({from: primary, data: contract.code}, function(error, contract){\n  if(!error && contract.address) {\n    admin.register(primary, contract.address, contenthash)\n    // put it up on your favourite oldworld site:\n    admin.registerUrl(contentHash, \"http://dapphub.com/test/info.json\")\n  }\n});\n```\n\n\n* contentHash\nデプロイしたContractの情報(mete data)を含むinfo.jsonファイルのハッシュ値。\n　これを登録する(admin.reister)\n\n* contentUrlを登録する\n - Urlは他の人が見れるサイト。info.jsonをアップロードしておく。\n - admin.registerUrlでそのUrlを登録する\n\n疑問\n\n* なぜわざわざ情報を登録するのか？jsonをアップロードとかめんどくさいしdecentralizedと言えない。ブロックチェーンで完結しないのか？\n\n参考サイト（上記）にこのような文言があった。\n\n```\nNote that if we use content addressed storage system like swarm the second step is unnecessary, since the contenthash is (deterministically translates to) the unique address of the content itself.\n```\n\nつまり、Swarmなどの分散データベースが実装されれば、contractにきちんと一意性のあるcontentHash値が得られるようになるが、いまはまだ実装できていないので、それまでは一意性が保てない。なので、どこかにmeta dataをアップロードしておかないと、そのcontractが信頼できるかわからない。metadataからハッシュ計算でcontentHashが得られるので、それと一致すれば良い。\n　なのでcontentUrlは単にファイルが見れる場所であればどこでもよい（はず）\n\n\n##Create and deploy GlobalRegistrar, HashReg and UrlHint\nきちんとデプロイするための方法が書いてある？（未読）\n\n####admin.setGlobalRegistrar();\n実装されてないとの書き込みが１０月の段階であったので今使えるか不明。以降の課題。\n","coediting":false,"created_at":"2015-11-30T00:52:49+09:00","id":"75b08c796df5dda8f8a3","private":false,"tags":[{"name":"JavaScript","versions":[]},{"name":"Bitcoin","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]},{"name":"仮想通貨","versions":[]}],"title":"Ethereumまとめメモ②","updated_at":"2015-11-30T00:52:49+09:00","url":"http://qiita.com/satons/items/75b08c796df5dda8f8a3","user":{"description":null,"facebook_id":null,"followees_count":2,"followers_count":7,"github_login_name":"starcharles","id":"satons","items_count":11,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":80546,"profile_image_url":"https://avatars.githubusercontent.com/u/7988311?v=3","twitter_screen_name":null,"website_url":null}},{"rendered_body":"<p>Gasについて<br>\n参考<br>\n<a href=\"https://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions\" class=\"autolink\">https://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions</a></p>\n\n<ul>\n<li><p>Gas<br>\ncontractを動かすために必要な量の単位(etherとは異なる）</p></li>\n<li><p>GasPrice<br>\nその時々で変化するgas価格<br>\n例）<br>\ngasprice= 0.001etherの時<br>\n10000gasが必要なら<br>\n0.001*10000=10etherを送金する必要がある</p></li>\n</ul>\n\n<p>contractに必要なgasの量は<br>\n\"web3.eth.estimateGas\"<br>\nでわかる<br>\n（実際に実行はされないが、必要なgas量を算出する関数）</p>\n\n<ul>\n<li>\n<p>GasLimit</p>\n\n<ul>\n<li>contractのaddressに送信できるGas量の限界値</li>\n<li>contractの発行者が決めて良い。</li>\n</ul>\n</li>\n</ul>\n\n<p>GasLimitが必要な理由<br>\n　 - contractにバグがありループが発生してしまう場合、それを止められなくなる。しかし、Gasが無くなるまでしかプログラムが動かないという制約を作ることで、無限ループなどでもgasがなくなれば実行が止まってくれる。送れるGasに限界量を設定するのはそのためである。<br>\n　 - ちなみに、gasが切れてしまった場合、ブロックチェーン上では、すべての処理はロールバックされ元の状態と変化しないで記録される。</p>\n\n<ul>\n<li>結局contractに必要なetherの量は</li>\n</ul>\n\n<p>（必要なgas量） × （その時のgasPrice）</p>\n\n<p>で算出</p>\n\n<p>Contract info (metadata)</p>\n\n<p>参考<br>\n<a href=\"https://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions\" class=\"autolink\">https://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions</a></p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>source = \"contract test {\n   /// @notice Will multiply `a` by 7.\n   function multiply(uint a) returns(uint d) {\n       return a * 7;\n   }\n}\"\ncontract = eth.compile.solidity(source).test\nMyContract = eth.contract(contract.info.abiDefinition)\ncontenthash = admin.saveInfo(contract.info, \"~/dapps/shared/contracts/test/info.json\")\nMyContract.new({from: primary, data: contract.code}, function(error, contract){\n  if(!error &amp;&amp; contract.address) {\n    admin.register(primary, contract.address, contenthash)\n    // put it up on your favourite oldworld site:\n    admin.registerUrl(contentHash, \"http://dapphub.com/test/info.json\")\n  }\n});\n</pre></div></div>\n\n<ul>\n<li><p>contentHash<br>\nデプロイしたContractの情報(mete data)を含むinfo.jsonファイルのハッシュ値。<br>\n　これを登録する(admin.reister)</p></li>\n<li>\n<p>contentUrlを登録する</p>\n\n<ul>\n<li>Urlは他の人が見れるサイト。info.jsonをアップロードしておく。</li>\n<li>admin.registerUrlでそのUrlを登録する</li>\n</ul>\n</li>\n</ul>\n\n<p>疑問</p>\n\n<ul>\n<li>なぜわざわざ情報を登録するのか？jsonをアップロードとかめんどくさいしdecentralizedと言えない。ブロックチェーンで完結しないのか？</li>\n</ul>\n\n<p>参考サイト（上記）にこのような文言があった。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>Note that if we use content addressed storage system like swarm the second step is unnecessary, since the contenthash is (deterministically translates to) the unique address of the content itself.\n</pre></div></div>\n\n<p>つまり、Swarmなどの分散データベースが実装されれば、contractにきちんと一意性のあるcontentHash値が得られるようになるが、いまはまだ実装できていないので、それまでは一意性が保てない。なので、どこかにmeta dataをアップロードしておかないと、そのcontractが信頼できるかわからない。metadataからハッシュ計算でcontentHashが得られるので、それと一致すれば良い。<br>\n　なのでcontentUrlは単にファイルが見れる場所であればどこでもよい（はず）</p>\n","body":"\n\nGasについて\n参考\nhttps://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions\n\n* Gas\ncontractを動かすために必要な量の単位(etherとは異なる）\n\n\n* GasPrice\nその時々で変化するgas価格\n例）\ngasprice= 0.001etherの時\n10000gasが必要なら\n0.001*10000=10etherを送金する必要がある\n\ncontractに必要なgasの量は\n\"web3.eth.estimateGas\"\nでわかる\n（実際に実行はされないが、必要なgas量を算出する関数）\n\n* GasLimit\n\n\t- contractのaddressに送信できるGas量の限界値\n\t- contractの発行者が決めて良い。\n\nGasLimitが必要な理由\n　\t- contractにバグがありループが発生してしまう場合、それを止められなくなる。しかし、Gasが無くなるまでしかプログラムが動かないという制約を作ることで、無限ループなどでもgasがなくなれば実行が止まってくれる。送れるGasに限界量を設定するのはそのためである。\n　\t- ちなみに、gasが切れてしまった場合、ブロックチェーン上では、すべての処理はロールバックされ元の状態と変化しないで記録される。\n\n* 結局contractに必要なetherの量は\n\n（必要なgas量） × （その時のgasPrice）\n\nで算出\n\nContract info (metadata)\n\n参考\nhttps://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions\n\n```\nsource = \"contract test {\n   /// @notice Will multiply `a` by 7.\n   function multiply(uint a) returns(uint d) {\n       return a * 7;\n   }\n}\"\ncontract = eth.compile.solidity(source).test\nMyContract = eth.contract(contract.info.abiDefinition)\ncontenthash = admin.saveInfo(contract.info, \"~/dapps/shared/contracts/test/info.json\")\nMyContract.new({from: primary, data: contract.code}, function(error, contract){\n  if(!error && contract.address) {\n    admin.register(primary, contract.address, contenthash)\n    // put it up on your favourite oldworld site:\n    admin.registerUrl(contentHash, \"http://dapphub.com/test/info.json\")\n  }\n});\n```\n\n\n* contentHash\nデプロイしたContractの情報(mete data)を含むinfo.jsonファイルのハッシュ値。\n　これを登録する(admin.reister)\n\n* contentUrlを登録する\n - Urlは他の人が見れるサイト。info.jsonをアップロードしておく。\n - admin.registerUrlでそのUrlを登録する\n\n疑問\n\n* なぜわざわざ情報を登録するのか？jsonをアップロードとかめんどくさいしdecentralizedと言えない。ブロックチェーンで完結しないのか？\n\n参考サイト（上記）にこのような文言があった。\n\n```\nNote that if we use content addressed storage system like swarm the second step is unnecessary, since the contenthash is (deterministically translates to) the unique address of the content itself.\n```\n\nつまり、Swarmなどの分散データベースが実装されれば、contractにきちんと一意性のあるcontentHash値が得られるようになるが、いまはまだ実装できていないので、それまでは一意性が保てない。なので、どこかにmeta dataをアップロードしておかないと、そのcontractが信頼できるかわからない。metadataからハッシュ計算でcontentHashが得られるので、それと一致すれば良い。\n　なのでcontentUrlは単にファイルが見れる場所であればどこでもよい（はず）\n\n","coediting":false,"created_at":"2015-11-30T00:52:19+09:00","id":"73ea9e5c096655cd8f8b","private":false,"tags":[{"name":"JavaScript","versions":[]},{"name":"Bitcoin","versions":[]},{"name":"Ethereum","versions":[]},{"name":"solidity","versions":[]},{"name":"仮想通貨","versions":[]}],"title":"Ethereumまとめメモ①","updated_at":"2015-12-20T18:07:01+09:00","url":"http://qiita.com/satons/items/73ea9e5c096655cd8f8b","user":{"description":null,"facebook_id":null,"followees_count":2,"followers_count":7,"github_login_name":"starcharles","id":"satons","items_count":11,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":80546,"profile_image_url":"https://avatars.githubusercontent.com/u/7988311?v=3","twitter_screen_name":null,"website_url":null}},{"rendered_body":"\n<h2>\n<span id=\"3つのステップ\" class=\"fragment\"></span><a href=\"#3%E3%81%A4%E3%81%AE%E3%82%B9%E3%83%86%E3%83%83%E3%83%97\"><i class=\"fa fa-link\"></i></a>3つのステップ</h2>\n\n<ol>\n<li>Erisプラットフォームのインストール</li>\n<li>あなた独自のブロックチェーンを作成</li>\n<li>スマートコントラクト・テンプレートとシンプルでWebベースのユーザインターフェイスを使って、分散型アプリを作成</li>\n</ol>\n\n<h2>\n<span id=\"step-1-インストール\" class=\"fragment\"></span><a href=\"#step-1-%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\"><i class=\"fa fa-link\"></i></a>Step 1: インストール</h2>\n\n<h3>\n<span id=\"依存\" class=\"fragment\"></span><a href=\"#%E4%BE%9D%E5%AD%98\"><i class=\"fa fa-link\"></i></a>依存</h3>\n\n<ul>\n<li>Docker</li>\n<li>Go</li>\n</ul>\n\n<p>インストールされているかの確認</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>$ (sudo) docker version\n$ go version &amp;&amp; echo $GOPATH\n</pre></div></div>\n\n<h3>\n<span id=\"インストール\" class=\"fragment\"></span><a href=\"#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\"><i class=\"fa fa-link\"></i></a>インストール</h3>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>$ go get github.com/eris-ltd/eris-cli/cmd/eris\n$ eris init\n</pre></div></div>\n\n<h2>\n<span id=\"step-2-あなた独自のブロックチェーンを作成\" class=\"fragment\"></span><a href=\"#step-2-%E3%81%82%E3%81%AA%E3%81%9F%E7%8B%AC%E8%87%AA%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%E3%82%92%E4%BD%9C%E6%88%90\"><i class=\"fa fa-link\"></i></a>Step 2: あなた独自のブロックチェーンを作成</h2>\n\n<p>デフォルトのgenesis.jsonを使って、test_chainという名前のものを作成</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>$ eris chains new test_chain\n</pre></div></div>\n\n<p>ブロックチェーンをローカルにインストール、ネットワークと同期する</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>$ eris chains install test_chain\n</pre></div></div>\n\n<p>既存のブロックチェーンと動かす</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>$ eris services start btcd\n$ eris services start bitcoinxt\n</pre></div></div>\n\n<p>ethereumの場合</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>$ eris services start eth\n</pre></div></div>\n\n<h2>\n<span id=\"step-3-あなたの分散型アプリを作る\" class=\"fragment\"></span><a href=\"#step-3-%E3%81%82%E3%81%AA%E3%81%9F%E3%81%AE%E5%88%86%E6%95%A3%E5%9E%8B%E3%82%A2%E3%83%97%E3%83%AA%E3%82%92%E4%BD%9C%E3%82%8B\"><i class=\"fa fa-link\"></i></a>Step 3: あなたの分散型アプリを作る</h2>\n\n<p>以下のドキュメントを参考にする</p>\n\n<ul>\n<li>分散型技術を学ぶ <a href=\"https://docs.erisindustries.com/tutorials/\">Eris Industries Documentation | Tutorials</a>\n</li>\n<li>Erisプラットフォームを始める <a href=\"https://eng.erisindustries.com/tutorials/2015/08/05/eris-services/\">Engineering DAPPs | Eris CLI Tool Walkabout: Services</a>\n</li>\n<li>スマートコントラクトを作る <a href=\"https://eng.erisindustries.com/tutorials/2015/03/11/solidity-1/\">Engineering DAPPs | Solidity Part I: An Introduction to Smart Systems of Smart Contracts</a>\n</li>\n<li>スマートコントラクトについて学ぶ <a href=\"https://docs.erisindustries.com/explainers/smart_contracts/\">Eris Industries Documentation | Explainer | Smart Contracts</a>\n</li>\n<li>ブロックチェーンについて学ぶ: <a href=\"https://docs.erisindustries.com/explainers/blockchains/\">Eris Industries Documentation | Explainer | Blockchains</a>\n</li>\n</ul>\n\n<h2>\n<span id=\"ドキュメント\" class=\"fragment\"></span><a href=\"#%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88\"><i class=\"fa fa-link\"></i></a>ドキュメント</h2>\n\n<p><a href=\"https://docs.erisindustries.com/\">Eris Industries Documentation | Getting Started With Eris</a></p>\n","body":"\n\n## 3つのステップ\n\n1. Erisプラットフォームのインストール\n2. あなた独自のブロックチェーンを作成\n3. スマートコントラクト・テンプレートとシンプルでWebベースのユーザインターフェイスを使って、分散型アプリを作成\n\n\n## Step 1: インストール\n\n### 依存\n\n* Docker\n* Go\n\nインストールされているかの確認\n\n```\n$ (sudo) docker version\n$ go version && echo $GOPATH\n```\n\n### インストール\n\n```\n$ go get github.com/eris-ltd/eris-cli/cmd/eris\n$ eris init\n```\n\n\n## Step 2: あなた独自のブロックチェーンを作成\n\nデフォルトのgenesis.jsonを使って、test_chainという名前のものを作成\n\n```\n$ eris chains new test_chain\n```\n\nブロックチェーンをローカルにインストール、ネットワークと同期する\n\n```\n$ eris chains install test_chain\n```\n\n既存のブロックチェーンと動かす\n\n```\n$ eris services start btcd\n$ eris services start bitcoinxt\n```\n\nethereumの場合\n\n```\n$ eris services start eth\n```\n\n## Step 3: あなたの分散型アプリを作る\n\n以下のドキュメントを参考にする\n\n* 分散型技術を学ぶ [Eris Industries Documentation | Tutorials](https://docs.erisindustries.com/tutorials/)\n* Erisプラットフォームを始める [Engineering DAPPs | Eris CLI Tool Walkabout: Services](https://eng.erisindustries.com/tutorials/2015/08/05/eris-services/)\n* スマートコントラクトを作る [Engineering DAPPs | Solidity Part I: An Introduction to Smart Systems of Smart Contracts](https://eng.erisindustries.com/tutorials/2015/03/11/solidity-1/)\n* スマートコントラクトについて学ぶ [Eris Industries Documentation | Explainer | Smart Contracts](https://docs.erisindustries.com/explainers/smart_contracts/)\n* ブロックチェーンについて学ぶ: [Eris Industries Documentation | Explainer | Blockchains](https://docs.erisindustries.com/explainers/blockchains/)\n\n\n## ドキュメント\n\n[Eris Industries Documentation | Getting Started With Eris](https://docs.erisindustries.com/)\n\n\n\n","coediting":false,"created_at":"2015-08-24T18:32:00+09:00","id":"a785d03064b9ba91a77f","private":false,"tags":[{"name":"Blockchain","versions":[]},{"name":"Ethereum","versions":[]},{"name":"Eris","versions":[]}],"title":"Eris のインストール、セットアップ方法","updated_at":"2015-08-24T18:32:00+09:00","url":"http://qiita.com/hshimo/items/a785d03064b9ba91a77f","user":{"description":"ブロックチェーン専門企業、コンセンサス・ベイス代表、志茂 博の技術メモ。\r\n興味ある方は、暗号通貨・ブロックチェーンのユーザグループへ。\r\nCryptocurrency Tech Japan\r\nhttp://crypto-tech.jp/","facebook_id":"","followees_count":6,"followers_count":208,"github_login_name":"hshimo","id":"hshimo","items_count":251,"linkedin_id":"","location":"","name":"Hiroshi Shimo","organization":"Consensus Base LLC.","permanent_id":24976,"profile_image_url":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/24976/32521deda72f5016c0b18055322400e6405a5183/medium.png?1438610616","twitter_screen_name":null,"website_url":""}}]}